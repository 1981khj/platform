var SideTable;

if (typeof WeakMap !== "undefined" && navigator.userAgent.indexOf("Firefox/") < 0) {
    SideTable = WeakMap;
} else {
    (function() {
        var defineProperty = Object.defineProperty;
        var hasOwnProperty = Object.hasOwnProperty;
        var counter = new Date().getTime() % 1e9;
        SideTable = function() {
            this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
        };
        SideTable.prototype = {
            set: function(key, value) {
                defineProperty(key, this.name, {
                    value: value,
                    writable: true
                });
            },
            get: function(key) {
                return hasOwnProperty.call(key, this.name) ? key[this.name] : undefined;
            }
        };
    })();
}

(function(exports) {
    "use strict";
    var wrapperTable = new SideTable();
    var constructorTable = new SideTable();
    function assert(b) {
        if (!b) throw new Error("Assertion failed");
    }
    function mixin(to, from) {
        Object.getOwnPropertyNames(from).forEach(function(name) {
            Object.defineProperty(to, name, Object.getOwnPropertyDescriptor(from, name));
        });
        return to;
    }
    function getWrapperConstructor(node) {
        var nativePrototype = node.__proto__ || Object.getPrototypeOf(node);
        var wrapperConstructor = constructorTable.get(nativePrototype);
        if (wrapperConstructor) return wrapperConstructor;
        var parentWrapperConstructor = getWrapperConstructor(nativePrototype);
        var GeneratedWrapper = createWrapperConstructor(parentWrapperConstructor);
        registerInternal(nativePrototype, GeneratedWrapper, node);
        return GeneratedWrapper;
    }
    function addForwardingProperties(nativePrototype, wrapperPrototype) {
        installProperty(nativePrototype, wrapperPrototype, true);
    }
    function registerInstanceProperties(wrapperPrototype, instanceObject) {
        installProperty(instanceObject, wrapperPrototype, false);
    }
    var isFirefox = /Firefox/.test(navigator.userAgent);
    var dummyDescriptor = {
        get: function() {},
        set: function(v) {},
        configurable: true,
        enumerable: true
    };
    function installProperty(source, target, allowMethod) {
        Object.getOwnPropertyNames(source).forEach(function(name) {
            if (name in target) return;
            if (isFirefox) {
                source.__lookupGetter__(name);
            }
            var descriptor;
            try {
                descriptor = Object.getOwnPropertyDescriptor(source, name);
            } catch (ex) {
                descriptor = dummyDescriptor;
            }
            var getter, setter;
            if (allowMethod && typeof descriptor.value === "function") {
                target[name] = function() {
                    return this.impl[name].apply(this.impl, arguments);
                };
                return;
            }
            getter = function() {
                return this.impl[name];
            };
            if (descriptor.writable || descriptor.set) {
                setter = function(value) {
                    this.impl[name] = value;
                };
            }
            Object.defineProperty(target, name, {
                get: getter,
                set: setter,
                configurable: descriptor.configurable,
                enumerable: descriptor.enumerable
            });
        });
    }
    function register(nativeConstructor, wrapperConstructor, opt_instance) {
        var nativePrototype = nativeConstructor.prototype;
        registerInternal(nativePrototype, wrapperConstructor, opt_instance);
    }
    function registerInternal(nativePrototype, wrapperConstructor, opt_instance) {
        var wrapperPrototype = wrapperConstructor.prototype;
        assert(constructorTable.get(nativePrototype) === undefined);
        constructorTable.set(nativePrototype, wrapperConstructor);
        addForwardingProperties(nativePrototype, wrapperPrototype);
        if (opt_instance) registerInstanceProperties(wrapperPrototype, opt_instance);
    }
    function registerObject(object, opt_nativeConstructor) {
        var nativePrototype = opt_nativeConstructor ? opt_nativeConstructor.prototype : Object.getPrototypeOf(object);
        var superWrapperConstructor = getWrapperConstructor(nativePrototype);
        var GeneratedWrapper = createWrapperConstructor(superWrapperConstructor);
        registerInternal(nativePrototype, GeneratedWrapper, object);
        return GeneratedWrapper;
    }
    function createWrapperConstructor(superWrapperConstructor) {
        function GeneratedWrapper(node) {
            superWrapperConstructor.call(this, node);
        }
        GeneratedWrapper.prototype = Object.create(superWrapperConstructor.prototype);
        return GeneratedWrapper;
    }
    function registerHTMLElement(tagName) {
        var element = document.createElement(tagName);
        if (element.constructor === HTMLElement || element instanceof HTMLUnknownElement) {
            return;
        }
        registerObject(element);
    }
    function wrap(node) {
        if (node === null) return null;
        assert(node instanceof Node || node instanceof Event);
        var wrapper = wrapperTable.get(node);
        if (!wrapper) {
            var wrapperConstructor = getWrapperConstructor(node);
            wrapper = new wrapperConstructor(node);
            wrapperTable.set(node, wrapper);
        }
        return wrapper;
    }
    function unwrap(wrapper) {
        if (wrapper === null) return null;
        assert(wrapper instanceof WrapperEventTarget || wrapper instanceof WrapperEvent);
        return wrapper.impl;
    }
    function rewrap(node, wrapper) {
        if (wrapper === null) return;
        assert(node instanceof Node || node instanceof Event);
        assert(wrapper === undefined || wrapper instanceof WrapperNode);
        wrapperTable.set(node, wrapper);
    }
    exports.mixin = mixin;
    exports.wrap = wrap;
    exports.unwrap = unwrap;
    exports.rewrap = rewrap;
    exports.wrappers = {
        register: register,
        registerHTMLElement: registerHTMLElement,
        registerObject: registerObject
    };
})(this);

(function(exports) {
    "use strict";
    function forwardElement(node) {
        while (node && node.nodeType !== Node.ELEMENT_NODE) {
            node = node.nextSibling;
        }
        return node;
    }
    function backwardsElement(node) {
        while (node && node.nodeType !== Node.ELEMENT_NODE) {
            node = node.previousSibling;
        }
        return node;
    }
    var ParentNodeInterface = {
        get firstElementChild() {
            return forwardElement(this.firstChild);
        },
        get lastElementChild() {
            return backwardsElement(this.lastChild);
        },
        get childElementCount() {
            var count = 0;
            for (var child = this.firstElementChild; child; child = child.nextElementSibling) {
                count++;
            }
            return count;
        },
        get children() {
            var wrapperList = new WrapperNodeList();
            var i = 0;
            for (var child = this.firstElementChild; child; child = child.nextElementSibling) {
                wrapperList[i++] = child;
            }
            wrapperList.length = i;
            return wrapperList;
        }
    };
    var ChildNodeInterface = {
        get nextElementSibling() {
            return forwardElement(this.nextSibling);
        },
        get previousElementSibling() {
            return backwardsElement(this.nextSibling);
        }
    };
    var SelectorsInterface = {
        querySelector: function(s) {
            return wrap(this.impl.querySelector(s));
        },
        querySelectorAll: function(s) {
            return wrapNodeList(this.impl.querySelectorAll(s));
        }
    };
    function addWrapGetter(wrapperConstructor, name) {
        Object.defineProperty(wrapperConstructor.prototype, name, {
            get: function() {
                return wrap(this.impl[name]);
            },
            configurable: true,
            enumerable: true
        });
    }
    function addWrapNodeListMethod(wrapperConstructor, name) {
        wrapperConstructor.prototype[name] = function() {
            return wrapNodeList(this.impl[name].apply(this.impl, arguments));
        };
    }
    exports.addWrapGetter = addWrapGetter;
    exports.addWrapNodeListMethod = addWrapNodeListMethod;
    exports.ChildNodeInterface = ChildNodeInterface;
    exports.ParentNodeInterface = ParentNodeInterface;
    exports.SelectorsInterface = SelectorsInterface;
})(this);

(function(exports) {
    "use strict";
    var wrappedFuns = new SideTable();
    var listenersTable = new SideTable();
    var handledEventsTable = new SideTable();
    var targetTable = new SideTable();
    var currentTargetTable = new SideTable();
    var eventPhaseTable = new SideTable();
    var stopPropagationTable = new SideTable();
    var stopImmediatePropagationTable = new SideTable();
    function isShadowRoot(node) {
        return node instanceof WrapperShadowRoot;
    }
    function isInsertionPoint(node) {
        var localName = node.localName;
        return localName === "content" || localName === "shadow";
    }
    function isShadowHost(node) {
        return !!node.shadowRoot;
    }
    function calculateParent(node, context) {
        if (isShadowRoot(node)) return node.insertionPointParent || getHostForShadowRoot(node);
        var p = node.insertionPointParent;
        if (p) return p;
        if (context && isInsertionPoint(node)) {
            var parentNode = node.parentNode;
            if (parentNode && isShadowHost(parentNode)) {
                var trees = getShadowTrees(parentNode);
                var p = context.insertionPointParent;
                for (var i = 0; i < trees.length; i++) {
                    if (trees[i].contains(p)) return p;
                }
            }
        }
        return node.parentNode;
    }
    function retarget(node) {
        var stack = [];
        var ancestor = node;
        var targets = [];
        while (ancestor) {
            var context = null;
            if (isInsertionPoint(ancestor)) {
                context = topMostNotInsertionPoint(stack);
                var top = stack[stack.length - 1] || ancestor;
                stack.push(top);
            }
            if (!stack.length) stack.push(ancestor);
            var target = stack[stack.length - 1];
            targets.push({
                target: target,
                ancestor: ancestor
            });
            if (isShadowRoot(ancestor)) stack.pop();
            ancestor = calculateParent(ancestor, context);
        }
        return targets;
    }
    function topMostNotInsertionPoint(stack) {
        for (var i = stack.length - 1; i >= 0; i--) {
            if (!isInsertionPoint(stack[i])) return stack[i];
        }
        return null;
    }
    function adjustRelatedTarget(target, related) {
        while (target) {
            var stack = [];
            var ancestor = related;
            var last = undefined;
            while (ancestor) {
                var context = null;
                if (!stack.length) {
                    stack.push(ancestor);
                } else {
                    if (isInsertionPoint(ancestor)) {
                        context = topMostNotInsertionPoint(stack);
                        if (isDistributed(last)) {
                            var head = stack[stack.length - 1];
                            stack.push(head);
                        }
                    }
                }
                if (inSameTree(ancestor, target)) return stack[stack.length - 1];
                if (isShadowRoot(ancestor)) stack.pop();
                last = ancestor;
                ancestor = calculateParent(ancestor, context);
            }
            if (isShadowRoot(target)) target = getHostForShadowRoot(target); else target = target.parentNode;
        }
    }
    function isDistributed(node) {
        return node.insertionPointParent;
    }
    function inSameTree(a, b) {
        while (true) {
            if (a === b) return a !== null;
            if (a) a = a.parentNode;
            if (b) b = b.parentNode;
        }
    }
    function dispatchOriginalEvent(originalEvent) {
        if (handledEventsTable.get(originalEvent)) return;
        handledEventsTable.set(originalEvent, true);
        var target = wrap(originalEvent.target);
        var event = wrap(originalEvent);
        return dispatchEvent(event, target);
    }
    function dispatchEvent(event, originalWrapperTarget) {
        var type = event.type;
        var bubbles = event.bubbles;
        var ancestorChain = retarget(originalWrapperTarget);
        var i = ancestorChain.length - 1;
        var phase = Event.CAPTURING_PHASE;
        eventPhaseTable.set(event, phase);
        var propagationStopped = false;
        for (;!propagationStopped && i > 0; i--) {
            propagationStopped = invoke(ancestorChain[i], event, type, phase);
        }
        phase = Event.AT_TARGET;
        eventPhaseTable.set(event, phase);
        if (!propagationStopped) {
            propagationStopped = invoke(ancestorChain[0], event, type, phase);
            i++;
        }
        if (bubbles) {
            phase = Event.BUBBLING_PHASE;
            eventPhaseTable.set(event, phase);
            for (;!propagationStopped && i < ancestorChain.length; i++) {
                propagationStopped = invoke(ancestorChain[i], event, type, phase);
            }
        }
        phase = Event.NONE;
        eventPhaseTable.set(event, phase);
        currentTargetTable.set(event, null);
        return event.defaultPrevented;
    }
    function invoke(tuple, event, type, phase) {
        var target = tuple.target;
        var currentTarget = tuple.ancestor;
        var listeners = listenersTable.get(currentTarget);
        if (!listeners) return;
        var anyRemoved = false;
        targetTable.set(event, target);
        currentTargetTable.set(event, currentTarget);
        for (var i = 0; i < listeners.length; i++) {
            var listener = listeners[i];
            if (listener.removed) {
                anyRemoved = true;
                continue;
            }
            if (listener.type !== type || !listener.capture && phase === Event.CAPTURING_PHASE || listener.capture && phase === Event.BUBBLING_PHASE) {
                continue;
            }
            try {
                if (typeof listener.handler === "function") listener.handler.call(currentTarget, event); else listener.handler.handleEvent(event);
                if (stopImmediatePropagationTable.get(event)) return true;
            } catch (ex) {
                if (window.onerror) window.onerror(ex.message); else console.error(ex);
            }
        }
        if (anyRemoved) {
            var copy = listeners.slice();
            listeners.length = 0;
            for (var i = 0; i < copy.length; i++) {
                if (!copy[i].removed) listeners.push(copy[i]);
            }
        }
        return stopPropagationTable.get(event);
    }
    function Listener(type, handler, capture) {
        this.type = type;
        this.handler = handler;
        this.capture = Boolean(capture);
    }
    Listener.prototype = {
        equals: function(that) {
            return this.handler === that.handler && this.type === that.type && this.capture === that.capture;
        },
        get removed() {
            return this.handler === null;
        },
        remove: function() {
            this.handler = null;
        }
    };
    function WrapperEvent(original) {
        this.impl = original;
    }
    WrapperEvent.prototype = {
        get target() {
            return targetTable.get(this);
        },
        get currentTarget() {
            return currentTargetTable.get(this);
        },
        get eventPhase() {
            return eventPhaseTable.get(this);
        },
        stopPropagation: function() {
            stopPropagationTable.set(this, true);
        },
        stopImmediatePropagation: function() {
            stopPropagationTable.set(this, true);
            stopImmediatePropagationTable.set(this, true);
        }
    };
    wrappers.register(Event, WrapperEvent, document.createEvent("Event"));
    function WrapperEventTarget(original) {
        this.impl = original;
    }
    WrapperEventTarget.prototype = {
        addEventListener: function(type, fun, capture) {
            var listener = new Listener(type, fun, capture);
            var listeners = listenersTable.get(this);
            if (!listeners) {
                listeners = [];
                listenersTable.set(this, listeners);
            } else {
                for (var i = 0; i < listeners.length; i++) {
                    if (listener.equals(listeners[i])) return;
                }
            }
            listeners.push(listener);
            unwrap(this).addEventListener(type, dispatchOriginalEvent, true);
        },
        removeEventListener: function(type, fun, capture) {
            var listeners = listenersTable.get(this);
            if (!listeners) return;
            var listener = new Listener(type, fun, capture);
            for (var i = 0; listeners.length; i++) {
                if (listener.equals(listeners[i])) {
                    listeners[i].remove();
                    return;
                }
            }
        },
        dispatchEvent: function(event) {
            return dispatchEvent(event, this);
        }
    };
    if (typeof EventTarget !== "undefined") wrappers.register(EventTarget, WrapperEventTarget);
    exports.WrapperEvent = WrapperEvent;
    exports.WrapperEventTarget = WrapperEventTarget;
    exports.adjustRelatedTarget = adjustRelatedTarget;
})(this);

(function(exports) {
    "use strict";
    function WrapperMouseEvent(original) {
        WrapperEvent.call(this, original);
    }
    WrapperMouseEvent.prototype = Object.create(WrapperEvent.prototype);
    addWrapGetter(WrapperMouseEvent, "relatedTarget");
    wrappers.register(MouseEvent, WrapperMouseEvent, document.createEvent("MouseEvent"));
    exports.WrapperMouseEvent = WrapperMouseEvent;
})(this);

(function(exports) {
    "use strict";
    function assert(b) {
        if (!b) throw new Error("Assertion failed");
    }
    function collectNodes(node, parentNode, previousNode, nextNode) {
        if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
            if (node.parentNode) node.parentNode.removeChild(node);
            node.parentNode_ = parentNode;
            node.previousSibling_ = previousNode;
            node.nextSibling_ = nextNode;
            if (previousNode) previousNode.nextSibling_ = node;
            if (nextNode) nextNode.previousSibling_ = node;
            return [ node ];
        }
        var nodes = [];
        var firstChild;
        while (firstChild = node.firstChild) {
            node.removeChild(firstChild);
            nodes.push(firstChild);
            firstChild.parentNode_ = parentNode;
        }
        for (var i = 0; i < nodes.length; i++) {
            nodes[i].previousSibling_ = nodes[i - 1] || previousNode;
            nodes[i].nextSibling_ = nodes[i + 1] || nextNode;
        }
        if (previousNode) previousNode.nextSibling_ = nodes[0];
        if (nextNode) nextNode.previousSibling_ = nodes[nodes.length - 1];
        return nodes;
    }
    function unwrapNodesForInsertion(nodes) {
        if (nodes.length === 1) return unwrap(nodes[0]);
        var df = unwrap(document.createDocumentFragment());
        for (var i = 0; i < nodes.length; i++) {
            df.appendChild(unwrap(nodes[i]));
        }
        return df;
    }
    function removeAllChildNodes(wrapper) {
        var childWrapper = wrapper.firstChild;
        while (childWrapper) {
            assert(childWrapper.parentNode === wrapper);
            var nextSibling = childWrapper.nextSibling;
            var childNode = unwrap(childWrapper);
            childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = null;
            var parentNode = childNode.parentNode;
            if (parentNode) parentNode.removeChild(childNode);
            childWrapper = nextSibling;
        }
        wrapper.firstChild_ = wrapper.lastChild_ = null;
    }
    function resetNodePointers(oldWrapper, newWrapper) {
        var w, p;
        if (w = oldWrapper.previousSibling) w.nextSibling_ = newWrapper;
        if (w = oldWrapper.nextSibling) w.previousSibling_ = newWrapper;
        if (p = oldWrapper.parentNode) {
            if (p.firstChild === oldWrapper) p.firstChild_ = newWrapper;
            if (p.lastChild === oldWrapper) p.lastChild_ = newWrapper;
        }
        newWrapper.parentNode_ = p;
        newWrapper.nextSibling_ = oldWrapper.nextSibling;
        newWrapper.previousSibling_ = oldWrapper.previousSibling;
        newWrapper.firstChild_ = oldWrapper.firstChild;
        newWrapper.lastChild_ = oldWrapper.lastChild;
        oldWrapper.node = oldWrapper.nextSibling_ = oldWrapper.previousSibling_ = oldWrapper.firstChild_ = oldWrapper.lastChild_ = undefined;
    }
    function WrapperNode(original) {
        assert(original instanceof Node);
        WrapperEventTarget.call(this, original);
        this.parentNode_ = undefined;
        this.firstChild_ = undefined;
        this.lastChild_ = undefined;
        this.nextSibling_ = undefined;
        this.previousSibling_ = undefined;
    }
    WrapperNode.prototype = Object.create(WrapperEventTarget.prototype);
    mixin(WrapperNode.prototype, {
        appendChild: function(childWrapper) {
            assert(childWrapper instanceof WrapperNode);
            this.invalidateShadowRenderer();
            var previousNode = this.lastChild;
            var nextNode = null;
            var nodes = collectNodes(childWrapper, this, previousNode, nextNode);
            this.lastChild_ = nodes[nodes.length - 1];
            if (!previousNode) this.firstChild_ = nodes[0];
            this.impl.appendChild(unwrapNodesForInsertion(nodes));
            return childWrapper;
        },
        insertBefore: function(childWrapper, refWrapper) {
            if (!refWrapper) return this.appendChild(childWrapper);
            assert(childWrapper instanceof WrapperNode);
            assert(refWrapper instanceof WrapperNode);
            assert(refWrapper.parentNode === this);
            this.invalidateShadowRenderer();
            var previousNode = refWrapper.previousSibling;
            var nextNode = refWrapper;
            var nodes = collectNodes(childWrapper, this, previousNode, nextNode);
            if (this.firstChild === refWrapper) this.firstChild_ = nodes[0];
            var refNode = unwrap(refWrapper);
            var parentNode = refNode.parentNode;
            if (parentNode) parentNode.insertBefore(unwrapNodesForInsertion(nodes), refNode);
            return childWrapper;
        },
        removeChild: function(childWrapper) {
            assert(childWrapper instanceof WrapperNode);
            if (childWrapper.parentNode !== this) {
                throw new Error("NotFoundError");
            }
            this.invalidateShadowRenderer();
            if (this.firstChild === childWrapper) this.firstChild_ = childWrapper.nextSibling;
            if (this.lastChild === childWrapper) this.lastChild_ = childWrapper.previousSibling;
            if (childWrapper.previousSibling) childWrapper.previousSibling.nextSibling_ = childWrapper.nextSibling;
            if (childWrapper.nextSibling) childWrapper.nextSibling.previousSibling_ = childWrapper.previousSibling;
            childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = null;
            var childNode = unwrap(childWrapper);
            var parentNode = childNode.parentNode;
            if (parentNode) parentNode.removeChild(childNode);
            return childWrapper;
        },
        replaceChild: function(newChildWrapper, oldChildWrapper) {
            assert(newChildWrapper instanceof WrapperNode);
            assert(oldChildWrapper instanceof WrapperNode);
            if (oldChildWrapper.parentNode !== this) {
                throw new Error("NotFoundError");
            }
            this.invalidateShadowRenderer();
            var previousNode = oldChildWrapper.previousSibling;
            var nextNode = oldChildWrapper.nextSibling;
            if (nextNode === newChildWrapper) nextNode = newChildWrapper.nextSibling;
            var nodes = collectNodes(newChildWrapper, this, previousNode, nextNode);
            if (this.firstChild === oldChildWrapper) this.firstChild_ = nodes[0];
            if (this.lastChild === oldChildWrapper) this.lastChild_ = nodes[nodes.length - 1];
            oldChildWrapper.previousSibling_ = null;
            oldChildWrapper.nextSibling_ = null;
            oldChildWrapper.parentNode_ = null;
            var oldChildNode = unwrap(oldChildWrapper);
            if (oldChildNode.parentNode) {
                oldChildNode.parentNode.replaceChild(unwrapNodesForInsertion(nodes), oldChildNode);
            }
            return oldChildWrapper;
        },
        hasChildNodes: function() {
            return this.firstChild === null;
        },
        get parentNode() {
            return this.parentNode_ !== undefined ? this.parentNode_ : wrap(this.impl.parentNode);
        },
        get firstChild() {
            return this.firstChild_ !== undefined ? this.firstChild_ : wrap(this.impl.firstChild);
        },
        get lastChild() {
            return this.lastChild_ !== undefined ? this.lastChild_ : wrap(this.impl.lastChild);
        },
        get nextSibling() {
            return this.nextSibling_ !== undefined ? this.nextSibling_ : wrap(this.impl.nextSibling);
        },
        get previousSibling() {
            return this.previousSibling_ !== undefined ? this.previousSibling_ : wrap(this.impl.previousSibling);
        },
        get parentElement() {
            var p = this.parentNode;
            while (p && p.nodeType !== Node.ELEMENT_NODE) {
                p = p.parentNode;
            }
            return p;
        },
        get textContent() {
            var s = "";
            for (var child = this.firstChild; child; child = child.nextSibling) {
                s += child.textContent;
            }
            return s;
        },
        set textContent(textContent) {
            removeAllChildNodes(this);
            this.invalidateShadowRenderer();
            if (textContent !== "") {
                var textNode = this.impl.ownerDocument.createTextNode(textContent);
                this.appendChild(textNode);
            }
        },
        get childNodes() {
            var wrapperList = new WrapperNodeList();
            var i = 0;
            for (var child = this.firstChild; child; child = child.nextSibling) {
                wrapperList[i++] = child;
            }
            wrapperList.length = i;
            return wrapperList;
        },
        cloneNode: function(deep) {
            if (!this.invalidateShadowRenderer()) return wrap(this.impl.cloneNode(deep));
            var clone = wrap(this.impl.cloneNode(false));
            if (deep) {
                for (var child = this.firstChild; child; child = child.nextSibling) {
                    clone.appendChild(child.cloneNode(true));
                }
            }
            return clone;
        },
        contains: function(child) {
            if (child === this) return true;
            var parentNode = child.parentNode;
            if (!parentNode) return false;
            return this.contains(parentNode);
        }
    });
    addWrapGetter(WrapperNode, "ownerDocument");
    wrappers.register(Node, WrapperNode, document.createDocumentFragment());
    delete WrapperNode.prototype.querySelector;
    delete WrapperNode.prototype.querySelectorAll;
    WrapperNode.prototype = mixin(Object.create(WrapperEventTarget.prototype), WrapperNode.prototype);
    exports.WrapperNode = WrapperNode;
    exports.resetNodePointers = resetNodePointers;
})(this);

(function(exports) {
    "use strict";
    function WrapperCharacterData(node) {
        WrapperNode.call(this, node);
    }
    WrapperCharacterData.prototype = Object.create(WrapperNode.prototype);
    mixin(WrapperCharacterData.prototype, {
        get textContent() {
            return this.data;
        },
        set textContent(value) {
            this.data = value;
        }
    });
    mixin(WrapperCharacterData.prototype, ChildNodeInterface);
    wrappers.register(CharacterData, WrapperCharacterData, document.createTextNode(""));
    exports.WrapperCharacterData = WrapperCharacterData;
})(this);

(function(exports) {
    "use strict";
    function nonEnum(obj, prop) {
        Object.defineProperty(obj, prop, {
            enumerable: false
        });
    }
    function WrapperNodeList() {
        this.length = 0;
        nonEnum(this, "length");
    }
    WrapperNodeList.prototype = {
        item: function(index) {
            return this[index];
        }
    };
    nonEnum(WrapperNodeList.prototype, "item");
    function wrapNodeList(list) {
        var wrapperList = new WrapperNodeList();
        for (var i = 0, length = list.length; i < length; i++) {
            wrapperList[i] = wrap(list[i]);
        }
        wrapperList.length = length;
        return wrapperList;
    }
    exports.wrapNodeList = wrapNodeList;
    exports.WrapperNodeList = WrapperNodeList;
})(this);

(function(exports) {
    "use strict";
    var shadowRootTable = new SideTable();
    function WrapperElement(node) {
        WrapperNode.call(this, node);
    }
    WrapperElement.prototype = Object.create(WrapperNode.prototype);
    mixin(WrapperElement.prototype, {
        createShadowRoot: function() {
            var newShadowRoot = new WrapperShadowRoot(this);
            shadowRootTable.set(this, newShadowRoot);
            var renderer = new ShadowRenderer(this);
            this.invalidateShadowRenderer();
            return newShadowRoot;
        },
        get shadowRoot() {
            return shadowRootTable.get(this) || null;
        },
        setAttribute: function(name, value) {
            this.impl.setAttribute(name, value);
            this.invalidateShadowRenderer();
        }
    });
    mixin(WrapperElement.prototype, ChildNodeInterface);
    mixin(WrapperElement.prototype, ParentNodeInterface);
    mixin(WrapperElement.prototype, SelectorsInterface);
    [ "getElementsByTagName", "getElementsByTagNameNS", "getElementsByClassName" ].forEach(function(name) {
        addWrapNodeListMethod(WrapperElement, name);
    });
    wrappers.register(Element, WrapperElement);
    exports.WrapperElement = WrapperElement;
})(this);

(function(exports) {
    "use strict";
    var escapeRegExp = /&|<|"/g;
    function escapeReplace(c) {
        switch (c) {
          case "&":
            return "&amp;";

          case "<":
            return "&lt;";

          case '"':
            return "&quot;";
        }
    }
    function escape(s) {
        return s.replace(escapeRegExp, escapeReplace);
    }
    var voidElements = {
        area: true,
        base: true,
        br: true,
        col: true,
        command: true,
        embed: true,
        hr: true,
        img: true,
        input: true,
        keygen: true,
        link: true,
        meta: true,
        param: true,
        source: true,
        track: true,
        wbr: true
    };
    function getOuterHTML(node) {
        switch (node.nodeType) {
          case Node.ELEMENT_NODE:
            var tagName = node.tagName.toLowerCase();
            var s = "<" + tagName;
            var attrs = node.attributes;
            for (var i = 0, attr; attr = attrs[i]; i++) {
                s += " " + attr.name + '="' + escape(attr.value) + '"';
            }
            s += ">";
            if (voidElements[tagName]) return s;
            return s + getInnerHTML(node) + "</" + tagName + ">";

          case Node.TEXT_NODE:
            return escape(node.nodeValue);

          case Node.COMMENT_NODE:
            return "<!--" + escape(node.nodeValue) + "-->";

          default:
            console.error(node);
            throw new Error("not implemented");
        }
    }
    function getInnerHTML(node) {
        var s = "";
        for (var child = node.firstChild; child; child = child.nextSibling) {
            s += getOuterHTML(child);
        }
        return s;
    }
    function setInnerHTML(node, value, opt_tagName) {
        var tagName = opt_tagName || "div";
        node.textContent = "";
        var tempElement = unwrap(node.ownerDocument.createElement(tagName));
        tempElement.innerHTML = value;
        var firstChild;
        while (firstChild = tempElement.firstChild) {
            node.appendChild(wrap(firstChild));
        }
    }
    function WrapperHTMLElement(node) {
        WrapperElement.call(this, node);
    }
    WrapperHTMLElement.prototype = Object.create(WrapperElement.prototype);
    mixin(WrapperHTMLElement.prototype, {
        get innerHTML() {
            return getInnerHTML(this);
        },
        set innerHTML(value) {
            setInnerHTML(this, value, this.tagName);
        },
        get outerHTML() {
            return getOuterHTML(this);
        },
        set outerHTML(value) {
            if (!this.invalidateShadowRenderer()) {
                this.impl.outerHTML = value;
            } else {
                throw new Error("not implemented");
            }
        }
    });
    function getterRequiresRendering(name) {
        Object.defineProperty(WrapperHTMLElement.prototype, name, {
            get: function() {
                renderAllPending();
                return this.impl[name];
            },
            configurable: true,
            enumerable: true
        });
    }
    [ "clientHeight", "clientLeft", "clientTop", "clientWidth", "offsetHeight", "offsetLeft", "offsetTop", "offsetWidth", "scrollHeight", "scrollLeft", "scrollTop", "scrollWidth" ].forEach(getterRequiresRendering);
    function methodRequiresRendering(name) {
        Object.defineProperty(WrapperHTMLElement.prototype, name, {
            value: function() {
                renderAllPending();
                return this.impl[name].apply(this.impl, arguments);
            },
            configurable: true,
            enumerable: true
        });
    }
    [ "getBoundingClientRect", "getClientRects", "scrollIntoView" ].forEach(methodRequiresRendering);
    wrappers.register(HTMLElement, WrapperHTMLElement, document.createElement("span"));
    exports.WrapperHTMLElement = WrapperHTMLElement;
    exports.getInnerHTML = getInnerHTML;
    exports.setInnerHTML = setInnerHTML;
})(this);

(function(exports) {
    "use strict";
    function WrapperHTMLUnknownElement(node) {
        switch (node.tagName) {
          case "CONTENT":
            return new WrapperHTMLContentElement(node);

          case "SHADOW":
            return new WrapperHTMLShadowElement(node);

          case "TEMPLATE":
            return new WrapperHTMLTemplateElement(node);
        }
        WrapperHTMLElement.call(this, node);
    }
    WrapperHTMLUnknownElement.prototype = Object.create(WrapperHTMLElement.prototype);
    wrappers.register(HTMLUnknownElement, WrapperHTMLUnknownElement);
    exports.WrapperHTMLUnknownElement = WrapperHTMLUnknownElement;
})(this);

(function(exports) {
    "use strict";
    function WrapperHTMLContentElement(node) {
        WrapperHTMLElement.call(this, node);
    }
    WrapperHTMLContentElement.prototype = Object.create(WrapperHTMLElement.prototype);
    mixin(WrapperHTMLContentElement.prototype, {
        get select() {
            return this.getAttribute("select");
        },
        set select(value) {
            this.setAttribute("select", value);
            this.invalidateShadowRenderer();
        }
    });
    if (typeof HTMLContentElement !== "undefined") wrappers.register(HTMLContentElement, WrapperHTMLContentElement);
    exports.WrapperHTMLContentElement = WrapperHTMLContentElement;
})(this);

(function(exports) {
    "use strict";
    function WrapperHTMLShadowElement(node) {
        WrapperHTMLElement.call(this, node);
        this.olderShadowRoot_ = null;
    }
    WrapperHTMLShadowElement.prototype = Object.create(WrapperHTMLElement.prototype);
    mixin(WrapperHTMLShadowElement.prototype, {
        get olderShadowRoot() {
            return this.olderShadowRoot_;
        }
    });
    if (typeof HTMLShadowElement !== "undefined") wrappers.register(HTMLShadowElement, WrapperHTMLShadowElement);
    exports.WrapperHTMLShadowElement = WrapperHTMLShadowElement;
})(this);

(function(exports) {
    "use strict";
    var hasNative = typeof HTMLTemplateElement !== "undefined";
    var contentTable = new SideTable();
    var templateContentsOwnerTable = new SideTable();
    function getTemplateContentsOwner(doc) {
        if (!doc.defaultView) return doc;
        var d = templateContentsOwnerTable.get(doc);
        if (!d) {
            d = doc.implementation.createHTMLDocument("");
            while (d.lastChild) {
                d.removeChild(d.lastChild);
            }
            templateContentsOwnerTable.set(doc, d);
        }
        return d;
    }
    function extractContent(templateElement) {
        var doc = getTemplateContentsOwner(templateElement.ownerDocument);
        var df = doc.createDocumentFragment();
        var nextSibling;
        var child;
        while (child = templateElement.firstChild) {
            df.appendChild(child);
        }
        return df;
    }
    function WrapperHTMLTemplateElement(node) {
        WrapperHTMLElement.call(this, node);
    }
    WrapperHTMLTemplateElement.prototype = Object.create(WrapperHTMLElement.prototype);
    mixin(WrapperHTMLTemplateElement.prototype, {
        get content() {
            if (hasNative) return wrap(this.impl.content);
            var content = contentTable.get(this);
            if (!content) {
                content = extractContent(this);
                contentTable.set(this, content);
            }
            return content;
        },
        get innerHTML() {
            return getInnerHTML(this.content);
        },
        set innerHTML(value) {
            setInnerHTML(this.content, value);
            this.invalidateShadowRenderer();
        }
    });
    if (hasNative) wrappers.register(HTMLTemplateElement, WrapperHTMLTemplateElement);
    exports.WrapperHTMLTemplateElement = WrapperHTMLTemplateElement;
})(this);

(function(exports) {
    "use strict";
    var WrapperDocumentFragment = wrappers.registerObject(document.createDocumentFragment());
    mixin(WrapperDocumentFragment.prototype, ParentNodeInterface);
    mixin(WrapperDocumentFragment.prototype, SelectorsInterface);
    wrappers.registerObject(document.createTextNode(""));
    wrappers.registerObject(document.createComment(""));
    exports.WrapperDocumentFragment = WrapperDocumentFragment;
})(this);

(function(exports) {
    "use strict";
    var shadowHostTable = new SideTable();
    function WrapperShadowRoot(hostWrapper) {
        var node = unwrap(hostWrapper.impl.ownerDocument.createDocumentFragment());
        WrapperDocumentFragment.call(this, node);
        rewrap(node, this);
        var oldShadowRoot = hostWrapper.shadowRoot;
        nextOlderShadowTreeTable.set(this, oldShadowRoot);
        shadowHostTable.set(this, hostWrapper);
        hostWrapper.invalidateShadowRenderer();
    }
    WrapperShadowRoot.prototype = Object.create(WrapperDocumentFragment.prototype);
    mixin(WrapperShadowRoot.prototype, {
        get innerHTML() {
            return getInnerHTML(this);
        },
        set innerHTML(value) {
            setInnerHTML(this, value);
            this.invalidateShadowRenderer();
        },
        invalidateShadowRenderer: function() {
            return shadowHostTable.get(this).invalidateShadowRenderer();
        }
    });
    exports.WrapperShadowRoot = WrapperShadowRoot;
    exports.getHostForShadowRoot = function(node) {
        return shadowHostTable.get(node);
    };
})(this);

(function(exports) {
    "use strict";
    function assert(b) {
        if (!b) throw new Error("Assertion failed");
    }
    function updateWrapperUpAndSideways(wrapper) {
        wrapper.previousSibling_ = wrapper.previousSibling;
        wrapper.nextSibling_ = wrapper.nextSibling;
        wrapper.parentNode_ = wrapper.parentNode;
    }
    function updateWrapperDown(wrapper) {
        wrapper.firstChild_ = wrapper.firstChild;
        wrapper.lastChild_ = wrapper.lastChild;
    }
    function updateAllChildNodes(parentNodeWrapper) {
        assert(parentNodeWrapper instanceof WrapperNode);
        for (var childWrapper = parentNodeWrapper.firstChild; childWrapper; childWrapper = childWrapper.nextSibling) {
            updateWrapperUpAndSideways(childWrapper);
        }
        updateWrapperDown(parentNodeWrapper);
    }
    function removeAllChildNodes(parentNodeWrapper) {
        var parentNode = unwrap(parentNodeWrapper);
        updateAllChildNodes(parentNodeWrapper);
        parentNode.textContent = "";
    }
    function appendChild(parentNodeWrapper, childWrapper) {
        var parentNode = unwrap(parentNodeWrapper);
        var child = unwrap(childWrapper);
        if (child.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            updateAllChildNodes(childWrapper);
        } else {
            remove(childWrapper);
            updateWrapperUpAndSideways(childWrapper);
        }
        parentNodeWrapper.lastChild_ = parentNodeWrapper.lastChild;
        if (parentNodeWrapper.lastChild === parentNodeWrapper.firstChild) parentNodeWrapper.firstChild_ = parentNodeWrapper.firstChild;
        var lastChildWrapper = wrap(parentNode.lastChild);
        if (lastChildWrapper) {
            lastChildWrapper.nextSibling_ = lastChildWrapper.nextSibling;
        }
        parentNode.appendChild(child);
    }
    function removeChild(parentNodeWrapper, childWrapper) {
        var parentNode = unwrap(parentNodeWrapper);
        var child = unwrap(childWrapper);
        updateWrapperUpAndSideways(childWrapper);
        if (childWrapper.previousSibling) childWrapper.previousSibling.nextSibling_ = childWrapper;
        if (childWrapper.nextSibling) childWrapper.nextSibling.previousSibling_ = childWrapper;
        if (parentNodeWrapper.lastChild === childWrapper) parentNodeWrapper.lastChild_ = childWrapper;
        if (parentNodeWrapper.firstChild === childWrapper) parentNodeWrapper.firstChild_ = childWrapper;
        parentNode.removeChild(child);
    }
    function remove(nodeWrapper) {
        var node = unwrap(nodeWrapper);
        var parentNode = node.parentNode;
        if (parentNode) removeChild(wrap(parentNode), nodeWrapper);
    }
    var distributedChildNodesTable = new SideTable();
    var shadowDOMRendererTable = new SideTable();
    var nextOlderShadowTreeTable = new SideTable();
    var insertionPointParentTable = new SideTable();
    function distributeChildToInsertionPoint(child, insertionPoint) {
        getDistributedChildNodes(insertionPoint).push(child);
        insertionPointParentTable.set(child, insertionPoint);
    }
    function resetDistributedChildNodes(insertionPoint) {
        distributedChildNodesTable.set(insertionPoint, []);
    }
    function getDistributedChildNodes(insertionPoint) {
        return distributedChildNodesTable.get(insertionPoint);
    }
    function getChildNodesSnapshot(node) {
        var result = [], i = 0;
        for (var child = node.firstChild; child; child = child.nextSibling) {
            result[i++] = child;
        }
        return result;
    }
    function visit(tree, predicate, visitor) {
        var nodes = getChildNodesSnapshot(tree);
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (predicate(node)) {
                if (visitor(node) === false) return;
            } else {
                visit(node, predicate, visitor);
            }
        }
    }
    function distribute(tree, pool) {
        var anyRemoved = false;
        visit(tree, isActiveInsertionPoint, function(insertionPoint) {
            resetDistributedChildNodes(insertionPoint);
            for (var i = 0; i < pool.length; i++) {
                var node = pool[i];
                if (node === undefined) continue;
                if (matchesCriteria(node, insertionPoint)) {
                    distributeChildToInsertionPoint(node, insertionPoint);
                    pool[i] = undefined;
                    anyRemoved = true;
                }
            }
        });
        if (!anyRemoved) return pool;
        var newPool = [];
        for (var i = 0; i < pool.length; i++) {
            if (pool[i] !== undefined) newPool.push(pool[i]);
        }
        return newPool;
    }
    var selectorMatchRegExp = /^[*.:#[a-zA-Z_|]/;
    var allowedPseudoRegExp = new RegExp("^:(" + [ "link", "visited", "target", "enabled", "disabled", "checked", "indeterminate", "nth-child", "nth-last-child", "nth-of-type", "nth-last-of-type", "first-child", "last-child", "first-of-type", "last-of-type", "only-of-type" ].join("|") + ")");
    function oneOf(object, propertyNames) {
        for (var i = 0; i < propertyNames.length; i++) {
            if (propertyNames[i] in object) return propertyNames[i];
        }
    }
    var matchesSelector = oneOf(document.documentElement, [ "matchesSelector", "msMatchesSelector", "mozMatchesSelector", "webkitMatchesSelector" ]);
    function matchesCriteria(node, point) {
        var select = point.getAttribute("select");
        if (!select) return true;
        select = select.trim();
        if (!select) return true;
        if (node.nodeType !== Node.ELEMENT_NODE) return false;
        if (!selectorMatchRegExp.test(select)) return false;
        if (select[0] === ":" && !allowedPseudoRegExp.test(select)) return false;
        try {
            return node[matchesSelector](select);
        } catch (ex) {
            return false;
        }
    }
    var request = oneOf(window, [ "requestAnimationFrame", "mozRequestAnimationFrame", "webkitRequestAnimationFrame", "setTimeout" ]);
    var pendingDirtyRenderers = [];
    var renderTimer;
    function renderAllPending() {
        renderTimer = null;
        pendingDirtyRenderers.forEach(function(owner) {
            owner.render();
        });
        pendingDirtyRenderers = [];
    }
    function ShadowRenderer(host) {
        this.host = host;
        this.dirty = false;
        this.associateNode(host);
    }
    ShadowRenderer.prototype = {
        render: function() {
            if (!this.dirty) return;
            var host = this.host;
            this.treeComposition();
            var shadowDOM = host.shadowRoot;
            if (!shadowDOM) return;
            this.removeAllChildNodes(this.host);
            var shadowDOMChildNodes = getChildNodesSnapshot(shadowDOM);
            shadowDOMChildNodes.forEach(function(node) {
                this.renderNode(host, shadowDOM, node, false);
            }, this);
            this.dirty = false;
        },
        invalidate: function() {
            if (!this.dirty) {
                this.dirty = true;
                pendingDirtyRenderers.push(this);
                if (renderTimer) return;
                renderTimer = window[request](renderAllPending, 0);
            }
        },
        renderNode: function(visualParent, tree, node, isNested) {
            if (isShadowHost(node)) {
                this.appendChild(visualParent, node);
                var renderer = new ShadowRenderer(node);
                renderer.render();
            } else if (isInsertionPoint(node)) {
                this.renderInsertionPoint(visualParent, tree, node, isNested);
            } else if (isShadowInsertionPoint(node)) {
                this.renderShadowInsertionPoint(visualParent, tree, node);
            } else {
                this.renderAsAnyDomTree(visualParent, tree, node, isNested);
            }
        },
        renderAsAnyDomTree: function(visualParent, tree, child, isNested) {
            this.appendChild(visualParent, child);
            if (isShadowHost(child)) {
                render(child);
            } else {
                var parent = child;
                var logicalChildNodes = getChildNodesSnapshot(parent);
                logicalChildNodes.forEach(function(node) {
                    this.renderNode(parent, tree, node, isNested);
                }, this);
            }
        },
        renderInsertionPoint: function(visualParent, tree, insertionPoint, isNested) {
            var distributedChildNodes = getDistributedChildNodes(insertionPoint);
            if (distributedChildNodes.length) {
                this.removeAllChildNodes(insertionPoint);
                distributedChildNodes.forEach(function(child) {
                    if (isInsertionPoint(child) && isNested) this.renderInsertionPoint(visualParent, tree, child, isNested); else this.renderAsAnyDomTree(visualParent, tree, child, isNested);
                }, this);
            } else {
                this.renderFallbackContent(visualParent, insertionPoint);
            }
            this.remove(insertionPoint);
        },
        renderShadowInsertionPoint: function(visualParent, tree, shadowInsertionPoint) {
            var nextOlderTree = getNextOlderTree(tree);
            if (nextOlderTree) {
                insertionPointParentTable.set(nextOlderTree, shadowInsertionPoint);
                shadowInsertionPoint.olderShadowRoot_ = nextOlderTree;
                this.remove(shadowInsertionPoint);
                var shadowDOMChildNodes = getChildNodesSnapshot(nextOlderTree);
                shadowDOMChildNodes.forEach(function(node) {
                    this.renderNode(visualParent, nextOlderTree, node, true);
                }, this);
            } else {
                this.renderFallbackContent(visualParent, shadowInsertionPoint);
            }
        },
        renderFallbackContent: function(visualParent, fallbackHost) {
            var logicalChildNodes = getChildNodesSnapshot(fallbackHost);
            logicalChildNodes.forEach(function(node) {
                this.appendChild(visualParent, node);
            }, this);
        },
        treeComposition: function() {
            var shadowHost = this.host;
            var tree = shadowHost.shadowRoot;
            var pool = [];
            var shadowHostChildNodes = getChildNodesSnapshot(shadowHost);
            shadowHostChildNodes.forEach(function(child) {
                if (isInsertionPoint(child)) {
                    var reprojected = getDistributedChildNodes(child);
                    if (!reprojected || !reprojected.length) reprojected = getChildNodesSnapshot(child);
                    pool.push.apply(pool, reprojected);
                } else {
                    pool.push(child);
                }
            });
            var shadowInsertionPoint, point;
            while (tree) {
                shadowInsertionPoint = undefined;
                visit(tree, isActiveShadowInsertionPoint, function(point) {
                    shadowInsertionPoint = point;
                    return false;
                });
                point = shadowInsertionPoint;
                pool = distribute(tree, pool);
                if (point) {
                    var nextOlderTree = getNextOlderTree(tree);
                    if (!nextOlderTree) {
                        break;
                    } else {
                        tree = nextOlderTree;
                        assignShadowTreeToShadowInsertionPoint(tree, point);
                        continue;
                    }
                } else {
                    break;
                }
            }
        },
        appendChild: function(parent, child) {
            appendChild(parent, child);
            this.associateNode(child);
        },
        remove: function(node) {
            remove(node);
            this.associateNode(node);
        },
        removeAllChildNodes: function(parent) {
            removeAllChildNodes(parent);
        },
        associateNode: function(node) {
            shadowDOMRendererTable.set(node, this);
        }
    };
    function isInsertionPoint(node) {
        return node.tagName == "CONTENT";
    }
    function isActiveInsertionPoint(node) {
        return node.tagName === "CONTENT";
    }
    function isShadowInsertionPoint(node) {
        return node.tagName === "SHADOW";
    }
    function isActiveShadowInsertionPoint(node) {
        return node.tagName === "SHADOW";
    }
    function isShadowHost(shadowHost) {
        return !!shadowHost.shadowRoot;
    }
    function getNextOlderTree(tree) {
        return nextOlderShadowTreeTable.get(tree);
    }
    function getShadowTrees(host) {
        var trees = [];
        for (var tree = host.shadowRoot; tree; tree = nextOlderShadowTreeTable.get(tree)) {
            trees.push(tree);
        }
        return trees;
    }
    function assignShadowTreeToShadowInsertionPoint(tree, point) {}
    function render(host) {
        new ShadowRenderer(host).render();
    }
    WrapperNode.prototype.invalidateShadowRenderer = function() {
        var renderer = shadowDOMRendererTable.get(this);
        if (!renderer) return false;
        renderer.invalidate();
        return true;
    };
    WrapperHTMLContentElement.prototype.getDistributedNodes = function() {
        renderAllPending();
        return getDistributedChildNodes(this);
    };
    mixin(WrapperNode.prototype, {
        get insertionPointParent() {
            return insertionPointParentTable.get(this) || null;
        }
    });
    exports.ShadowRenderer = ShadowRenderer;
    exports.renderAllPending = renderAllPending;
    exports.nextOlderShadowTreeTable = nextOlderShadowTreeTable;
    exports.getShadowTrees = getShadowTrees;
    exports.visual = {
        removeAllChildNodes: removeAllChildNodes,
        appendChild: appendChild,
        removeChild: removeChild
    };
})(this);

(function(exports) {
    "use strict";
    var implementationTable = new SideTable();
    function WrapperDocument(node) {
        WrapperNode.call(this, node);
    }
    WrapperDocument.prototype = Object.create(WrapperNode.prototype);
    addWrapGetter(WrapperDocument, "documentElement");
    addWrapGetter(WrapperDocument, "body");
    addWrapGetter(WrapperDocument, "head");
    mixin(WrapperDocument.prototype, ParentNodeInterface);
    mixin(WrapperDocument.prototype, {
        get implementation() {
            var implementation = implementationTable.get(this);
            if (implementation) return implementation;
            implementation = new WrapperDOMImplementation(unwrap(this).implementation);
            implementationTable.set(this, implementation);
            return implementation;
        }
    });
    wrappers.register(Document, WrapperDocument, document.implementation.createHTMLDocument(""));
    exports.WrapperDocument = WrapperDocument;
    if (typeof HTMLDocument !== "undefined") wrappers.register(HTMLDocument, WrapperDocument);
    function wrapMethod(name) {
        var proto = Object.getPrototypeOf(document);
        var original = proto[name];
        proto[name] = function() {
            return wrap(original.apply(this, arguments));
        };
        WrapperDocument.prototype[name] = function() {
            return wrap(original.apply(this.impl, arguments));
        };
    }
    [ "getElementById", "querySelector", "createElement", "createElementNS", "createTextNode", "createDocumentFragment", "createEvent", "createEventNS" ].forEach(wrapMethod);
    function wrapNodeListMethod(name) {
        var proto = Object.getPrototypeOf(document);
        var original = proto[name];
        proto[name] = function() {
            return wrapNodeList(original.apply(this, arguments));
        };
        WrapperDocument.prototype[name] = function() {
            return wrapNodeList(original.apply(this.impl, arguments));
        };
    }
    [ "getElementsByTagName", "getElementsByTagNameNS", "getElementsByClassName", "querySelectorAll" ].forEach(wrapNodeListMethod);
    function wrapImplMethod(constructor, name) {
        constructor.prototype[name] = function() {
            return wrap(this.impl[name].apply(this.impl, arguments));
        };
    }
    function forwardImplMethod(constructor, name) {
        constructor.prototype[name] = function() {
            return this.impl[name].apply(this.impl, arguments);
        };
    }
    function WrapperDOMImplementation(node) {
        this.impl = node;
    }
    wrapImplMethod(WrapperDOMImplementation, "createDocumentType");
    wrapImplMethod(WrapperDOMImplementation, "createDocument");
    wrapImplMethod(WrapperDOMImplementation, "createHTMLDocument");
    forwardImplMethod(WrapperDOMImplementation, "hasFeature");
})(this);

(function() {
    var WebComponents = {
        preloadSelectors: [ "link[rel=component]", "script[src]", "link[rel=stylesheet]" ],
        preload: function(inDocument, inNext) {
            wc.cache = loader.cache;
            var nodes = inDocument.querySelectorAll(wc.preloadSelectors);
            nodes = Array.prototype.filter.call(nodes, function(n) {
                return n.localName !== "script" || n.ownerDocument !== document;
            });
            loader.loadAll(nodes, inNext, wc.eachPreload);
        },
        eachPreload: function(data, next, url, elt) {
            if (wc.isDocumentLink(elt)) {
                var document = makeDocument(data, url);
                elt.component = elt.__resource = loader.cache[url] = document;
                WebComponents.preload(document, next);
            } else {
                next();
            }
        },
        isDocumentLink: function(inElt) {
            return inElt.localName === "link" && inElt.getAttribute("rel") === "component";
        }
    };
    var wc = WebComponents;
    wc.preloadSelectors = wc.preloadSelectors.join(",");
    var makeDocument = function(inHTML, inUrl) {
        var doc = document.implementation.createHTMLDocument("component");
        doc.body.innerHTML = inHTML;
        doc._URL = inUrl;
        return doc;
    };
    loader = {
        cache: {},
        loadAll: function(inNodes, inNext, inEach) {
            if (!inNodes.length) {
                inNext();
            }
            var inflight = 0;
            function head(inElt) {
                inflight++;
                var url = path.nodeUrl(inElt);
                var resource = loader.cache[url];
                if (resource) {
                    inElt.__resource = resource;
                    tail();
                }
                xhr.load(url, function(err, resource, url) {
                    if (err) {
                        tail();
                    } else {
                        inElt.__resource = loader.cache[url] = resource;
                        each(resource, tail, url, inElt);
                    }
                });
            }
            function tail() {
                if (!--inflight) {
                    inNext();
                }
            }
            var each = inEach || tail;
            forEach(inNodes, head);
        }
    };
    var path = {
        nodeUrl: function(inNode) {
            return path.resolveNodeUrl(inNode, path.hrefOrSrc(inNode));
        },
        hrefOrSrc: function(inNode) {
            return inNode.getAttribute("href") || inNode.getAttribute("src");
        },
        resolveNodeUrl: function(inNode, inRelativeUrl) {
            return this.resolveUrl(this.documentUrlFromNode(inNode), inRelativeUrl);
        },
        documentUrlFromNode: function(inNode) {
            var d = inNode.ownerDocument;
            var url = d && (d._URL || d.URL || window.unwrap && unwrap(d)._URL) || "";
            url = url.split("#")[0];
            return url;
        },
        resolveUrl: function(inBaseUrl, inUrl) {
            if (this.isAbsUrl(inUrl)) {
                return inUrl;
            }
            return this.compressUrl(this.urlToPath(inBaseUrl) + inUrl);
        },
        isAbsUrl: function(inUrl) {
            return /(^data:)|(^http[s]?:)|(^\/)/.test(inUrl);
        },
        urlToPath: function(inBaseUrl) {
            var parts = inBaseUrl.split("/");
            parts.pop();
            parts.push("");
            return parts.join("/");
        },
        compressUrl: function(inUrl) {
            var parts = inUrl.split("/");
            for (var i = 0, p; i < parts.length; i++) {
                p = parts[i];
                if (p === "..") {
                    parts.splice(i - 1, 2);
                    i -= 2;
                }
            }
            return parts.join("/");
        }
    };
    var xhr = {
        async: true,
        ok: function(inRequest) {
            return inRequest.status >= 200 && inRequest.status < 300 || inRequest.status === 304;
        },
        load: function(url, next, nextContext) {
            var request = new XMLHttpRequest();
            request.open("GET", url + "?" + Math.random(), xhr.async);
            request.addEventListener("readystatechange", function(e) {
                if (request.readyState === 4) {
                    next.call(nextContext, !xhr.ok(request) && request, request.response, url);
                }
            });
            request.send();
        }
    };
    var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
    window.WebComponents = WebComponents;
    window.addEventListener("load", function() {
        WebComponents.preload(document, function() {
            var sdocument = window.wrap ? wrap(document) : document;
            sdocument.body.dispatchEvent(new CustomEvent("WebComponentsLoaded", {
                bubbles: true
            }));
        });
    });
})();

(function() {
    function register(inName, inOptions) {
        var definition = inOptions || {};
        definition.name = inName;
        definition.lifecycle = definition.lifecycle || {};
        definition.prototype = definition.prototype || Object.create(HTMLUnknownElement.prototype);
        definition.ancestry = ancestry(definition.extends);
        resolveTagName(definition);
        resolvePrototypeChain(definition);
        registerDefinition(inName, definition);
        definition.ctor = generateConstructor(definition);
        definition.ctor.prototype = definition.prototype;
        document.upgradeElements();
        return definition.ctor;
    }
    function ancestry(inExtends) {
        var extendee = registry[inExtends];
        if (extendee) {
            return ancestry(extendee.extends).concat([ extendee ]);
        }
        return [];
    }
    function resolveTagName(inDefinition) {
        var baseTag = inDefinition.extends;
        for (var i = 0, a; a = inDefinition.ancestry[i]; i++) {
            baseTag = a.is && a.tag;
        }
        inDefinition.tag = baseTag || inDefinition.name;
        if (baseTag) {
            inDefinition.is = inDefinition.name;
        }
    }
    function resolvePrototypeChain(inDefinition) {
        if (window.WrapperElement && !(inDefinition.prototype instanceof WrapperElement)) {
            if (inDefinition.is) {
                var inst = domCreateElement(inDefinition.tag);
                var native = Object.getPrototypeOf(unwrap(inst));
                var wrapperNative = Object.getPrototypeOf(inst);
            } else {
                native = HTMLElement.prototype;
                wrapperNative = WrapperHTMLUnknownElement.prototype;
            }
            if (Object.__proto__) {
                var p = inDefinition.prototype, pp;
                while (true) {
                    pp = Object.getPrototypeOf(p);
                    if (pp === native || pp == HTMLUnknownElement.prototype) {
                        break;
                    }
                    p = pp;
                }
                p.__proto__ = wrapperNative;
            } else {}
        }
    }
    function instantiate(inDefinition) {
        return upgrade(domCreateElement(inDefinition.tag), inDefinition);
    }
    function upgrade(inElement, inDefinition) {
        implement(inElement, inDefinition);
        if (inDefinition.is) {
            inElement.setAttribute("is", inDefinition.is);
        }
        inElement.__upgraded__ = true;
        created(inElement, inDefinition);
        return inElement;
    }
    function implement(inElement, inDefinition) {
        if (Object.__proto__) {
            inElement.__proto__ = inDefinition.prototype;
        } else {
            if (!Object.__proto__) {
                inElement.__proto__ = inDefinition.prototype;
            }
            mixin(inElement, inPrototype);
        }
    }
    function created(inElement, inDefinition) {
        var readyCallback = inDefinition.lifecycle.readyCallback || inElement.readyCallback;
        if (readyCallback) {
            readyCallback.call(inElement);
        }
    }
    var registry = {};
    var registrySlctr = "";
    function registerDefinition(inName, inDefinition) {
        registry[inName] = inDefinition;
        registrySlctr += registrySlctr ? "," : "";
        if (inDefinition.extends) {
            registrySlctr += inDefinition.tag + "[is=" + inDefinition.is + "],";
        }
        registrySlctr += inName;
    }
    function generateConstructor(inDefinition) {
        return function() {
            return instantiate(inDefinition);
        };
    }
    function createElement(inTag) {
        var definition = registry[inTag];
        if (definition) {
            return new definition.ctor();
        }
        return domCreateElement(inTag);
    }
    function upgradeElement(inElement) {
        if (!inElement.__upgraded__) {
            var type = inElement.getAttribute("is") || inElement.localName;
            var definition = registry[type];
            return definition && upgrade(inElement, definition);
        }
    }
    function upgradeElements(inRoot, inSlctr) {
        var slctr = inSlctr || registrySlctr;
        if (slctr) {
            var root = inRoot || document;
            forEach(root.querySelectorAll(slctr), upgradeElement);
        }
    }
    var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
    function mixin(inObj) {
        var obj = inObj || {};
        for (var i = 1; i < arguments.length; i++) {
            var p = arguments[i];
            try {
                for (var n in p) {
                    copyProperty(n, p, obj);
                }
            } catch (x) {}
        }
        return obj;
    }
    function copyProperty(inName, inSource, inTarget) {
        var pd = getPropertyDescriptor(inSource, inName);
        Object.defineProperty(inTarget, inName, pd);
    }
    function getPropertyDescriptor(inObject, inName) {
        if (inObject) {
            var pd = Object.getOwnPropertyDescriptor(inObject, inName);
            return pd || getPropertyDescriptor(Object.getPrototypeOf(inObject), inName);
        }
    }
    var domCreateElement = document.createElement.bind(document);
    document.register = register;
    document.upgradeElement = upgradeElement;
    document.upgradeElements = upgradeElements;
    document.createElement = createElement;
    window.mixin = mixin;
})();

(function() {
    var HTMLElementElement = function(inElement) {
        inElement.register = HTMLElementElement.prototype.register;
        parseElementElement(inElement);
        return inElement;
    };
    HTMLElementElement.prototype = {
        register: function(inMore) {
            if (inMore) {
                this.options.lifecycle = inMore.lifecycle;
                if (inMore.prototype) {
                    mixin(this.options.prototype, inMore.prototype);
                }
            }
        }
    };
    function parseElementElement(inElement) {
        var options = {
            name: "",
            "extends": null
        };
        takeAttributes(inElement, options);
        var base = HTMLElement.prototype;
        if (options.extends) {
            var archetype = document.createElement(options.extends);
            base = Object.getPrototypeOf(archetype);
        }
        options.prototype = Object.create(base);
        inElement.options = options;
        var script = inElement.querySelector("script,scripts");
        if (script) {
            executeComponentScript(script.textContent, inElement, options.name);
        }
        document.register(options.name, options);
    }
    function takeAttributes(inElement, inDictionary) {
        for (var n in inDictionary) {
            var a = inElement.attributes[n];
            if (a) {
                inDictionary[n] = a.value;
            }
        }
    }
    function executeComponentScript(inScript, inContext, inName) {
        context = inContext;
        var owner = context.ownerDocument;
        var code = "__componentScript('" + inName + "', function(){" + inScript + "});" + "\n//@ sourceURL=" + (owner._URL || owner.URL) + "\n";
        eval(code);
    }
    var context;
    window.__componentScript = function(inName, inFunc) {
        inFunc.call(context);
    };
    window.HTMLElementElement = HTMLElementElement;
})();

(function() {
    var sdocument = window.wrap ? wrap(document) : document;
    var componentParser = {
        selectors: [ "link[rel=component]", "link[rel=stylesheet]", "script[src]", "script", "style", "element" ],
        map: {
            link: "parseLink",
            script: "parseScript",
            element: "parseElement",
            style: "parseStyle"
        },
        parse: function(inDocument) {
            if (inDocument) {
                document.upgradeElements(inDocument);
                var elts = inDocument.querySelectorAll(cp.selectors);
                forEach(elts, function(e) {
                    cp[cp.map[e.localName]](e);
                });
                document.upgradeElements(inDocument);
            }
        },
        parseLink: function(inLinkElt) {
            if (this.isDocumentLink(inLinkElt)) {
                cp.parse(inLinkElt.__resource);
            } else {}
        },
        isDocumentLink: function(inElt) {
            return inElt.localName === "link" && inElt.getAttribute("rel") === "component";
        },
        parseScript: function(inScriptElt) {
            if (inScriptElt.ownerDocument === sdocument) {
                return;
            }
            if (inScriptElt.parentNode.localName === "element") {
                return;
            }
            var code = inScriptElt.__resource || inScriptElt.textContent;
            if (code) {
                eval(code);
            }
        },
        parseStyle: function(inStyleElt) {
            document.querySelector("head").appendChild(inStyleElt);
        },
        parseElement: function(inElementElt) {
            var element = inElementElt;
            new HTMLElementElement(element);
        }
    };
    var cp = componentParser;
    var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
    function bootstrap() {
        componentParser.parse(document);
        sdocument.body.dispatchEvent(new CustomEvent("WebComponentsReady", {
            bubbles: true
        }));
    }
    var parseTimeEvent = window.WebComponents ? "WebComponentsLoaded" : "load";
    sdocument.addEventListener(parseTimeEvent, function() {
        setTimeout(bootstrap, 0);
    });
})();

var generateMatcher = function(inSlctr) {
    if (!inSlctr) {
        return;
    }
    var c = inSlctr[0];
    if (inSlctr === "~") {
        return function(inNode) {
            return Boolean(inNode.lightDOM);
        };
    }
    if (c === "#") {
        m = inSlctr.slice(1);
        return function(inNode) {
            return inNode.id === m;
        };
    }
    if (inSlctr === "*") {
        return function(inNode) {
            return inNode.nodeName !== "#text";
        };
    }
    if (c === ".") {
        m = inSlctr.slice(1);
        return function(inNode) {
            return inNode.classList && inNode.classList.contains(m);
        };
    }
    if (c === "[") {
        m = inSlctr.slice(1, -1);
        return function(inNode) {
            return inNode.hasAttribute && inNode.hasAttribute(m);
        };
    }
    var slctrs = inSlctr.toLowerCase().split(",");
    return function(inNode) {
        return slctrs.indexOf(inNode.localName) >= 0;
    };
};

var isInsertionPoint = function(inNode) {
    return {
        SHADOW: 1,
        CONTENT: 1
    }[inNode.tagName];
};

var search = function(inNodes, inMatcher) {
    var results = [];
    for (var i = 0, n; n = inNodes[i]; i++) {
        if (inMatcher(n)) {
            results.push(n);
        }
        if (!isInsertionPoint(n)) {
            results = results.concat(_search(n, inMatcher));
        }
    }
    return results;
};

var _search = function(inNode, inMatcher) {
    return search(inNode.childNodes, inMatcher);
};

var localQueryAll = function(inNode, inSlctr) {
    var results = search(inNode.childNodes, generateMatcher(inSlctr));
    return results;
};

var localQuery = function(inNode, inSlctr) {
    return localQueryAll(inNode, inSlctr)[0];
};

(function() {
    var inspector;
    window.sinspect = function(inNode, inProxy) {
        if (!inspector) {
            inspector = window.open("", "ShadowDOM Inspector", null, true);
            inspector.document.write(extractHtml(containHtml.toString()));
            inspector.api = {
                shadowize: shadowize
            };
        }
        inspect(inNode || SDOM(document.body), inProxy);
    };
    var crumbs = [];
    var displayCrumbs = function() {
        var d = inspector.document;
        var cb = d.querySelector("#crumbs");
        cb.textContent = "";
        for (var i = 0, c; c = crumbs[i]; i++) {
            var a = d.createElement("a");
            a.href = "#";
            a.textContent = c.localName;
            a.idx = i;
            a.onclick = function(event) {
                var c;
                while (crumbs.length > this.idx) {
                    c = crumbs.pop();
                }
                inspect(c.shadow || c, c);
                event.preventDefault();
            };
            cb.appendChild(d.createElement("li")).appendChild(a);
        }
    };
    var inspect = function(inNode, inProxy) {
        var d = inspector.document;
        drillable = [];
        var proxy = inProxy || inNode;
        crumbs.push(proxy);
        displayCrumbs();
        d.body.querySelector("#tree").innerHTML = "<pre>" + output(inNode, inNode.childNodes) + "</pre>";
    };
    var containHtml = function() {};
    var extractHtml = function(inCode) {
        var rx = /\/\*[\w\t\n\r]*([\s\S]*?)[\w\t\n\r]*\*\//;
        var html = inCode.toString().match(rx)[1];
        return html;
    };
    var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
    var blacklisted = {
        STYLE: 1,
        SCRIPT: 1,
        "#comment": 1,
        TEMPLATE: 1
    };
    var blacklist = function(inNode) {
        return blacklisted[inNode.nodeName];
    };
    var output = function(inNode, inChildNodes, inIndent) {
        if (blacklist(inNode)) {
            return "";
        }
        var indent = inIndent || "";
        if (inNode.localName || inNode.nodeType == 11) {
            var name = inNode.localName || "shadow-root";
            var info = indent + describe(inNode);
            {
                if (name == "content" || name == "shadow") {
                    inChildNodes = inNode.getDistributedNodes();
                }
                info += "<br/>";
                var ind = indent + "&nbsp;&nbsp;";
                forEach(inChildNodes, function(n) {
                    info += output(n, n.childNodes, ind);
                });
                info += indent;
            }
            if (!{
                br: 1
            }[name]) {
                info += "<tag>&lt;/" + name + "&gt;</tag>";
                info += "<br/>";
            }
        } else {
            var text = inNode.textContent.trim();
            info = text ? indent + '"' + text + '"' + "<br/>" : "";
        }
        return info;
    };
    var catTextContent = function(inChildNodes) {
        var info = "";
        forEach(inChildNodes, function(n) {
            info += n.textContent.trim();
        });
        return info;
    };
    var drillable = [];
    var describe = function(inNode) {
        var tag = "<tag>" + "&lt;";
        var name = inNode.localName || "shadow-root";
        if (inNode.webkitShadowRoot || inNode.shadowRoot) {
            tag += ' <button idx="' + drillable.length + '" onclick="api.shadowize.call(this)">' + name + "</button>";
            drillable.push(inNode);
        } else {
            tag += name || "shadow-root";
        }
        if (inNode.attributes) {
            forEach(inNode.attributes, function(a) {
                tag += " " + a.name + (a.value ? '="' + a.value + '"' : "");
            });
        }
        tag += "&gt;" + "</tag>";
        return tag;
    };
    shadowize = function() {
        var idx = Number(this.attributes.idx.value);
        var node = drillable[idx];
        if (node) {
            sinspect(node.webkitShadowRoot || node.shadowRoot, node);
        } else {
            console.log("bad shadowize node");
            console.dir(this);
        }
    };
})();

window.templateContent = window.templateContent || function(inTemplate) {
    return inTemplate.content;
};

if (!window.WrapperElement) {
    window.wrap = function(n) {
        return n;
    };
    window.createShadowRoot = function(inElement) {
        return inElement.webkitCreateShadowRoot();
    };
    window.templateContent = function(inTemplate) {
        if (!inTemplate.content && !inTemplate._content) {
            var frag = document.createDocumentFragment();
            while (inTemplate.firstChild) {
                frag.appendChild(inTemplate.firstChild);
            }
            inTemplate._content = frag;
        }
        return inTemplate.content || inTemplate._content;
    };
} else {
    var queryPropDefs = {
        querySelector: {
            value: function(inSlctr) {
                return localQuery(this, inSlctr);
            }
        },
        querySelectorAll: {
            value: function(inSlctr) {
                return localQueryAll(this, inSlctr);
            }
        }
    };
    Object.defineProperties(WrapperElement.prototype, queryPropDefs);
    Object.defineProperties(WrapperDocument.prototype, queryPropDefs);
    Object.defineProperties(WrapperShadowRoot.prototype, queryPropDefs);
    Object.defineProperties(WrapperElement.prototype, {
        webkitShadowRoot: {
            get: function() {
                return this.shadowRoot;
            }
        }
    });
    WrapperElement.prototype.webkitCreateShadowRoot = WrapperElement.prototype.createShadowRoot;
}