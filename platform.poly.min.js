var SideTable;

if (typeof WeakMap !== "undefined" && navigator.userAgent.indexOf("Firefox/") < 0) {
    SideTable = WeakMap;
} else {
    (function() {
        var defineProperty = Object.defineProperty;
        var hasOwnProperty = Object.hasOwnProperty;
        var counter = new Date().getTime() % 1e9;
        SideTable = function() {
            this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
        };
        SideTable.prototype = {
            set: function(key, value) {
                defineProperty(key, this.name, {
                    value: value,
                    writable: true
                });
            },
            get: function(key) {
                return hasOwnProperty.call(key, this.name) ? key[this.name] : undefined;
            }
        };
    })();
}

(function(exports) {
    "use strict";
    var wrapperTable = new SideTable();
    var constructorTable = new SideTable();
    function assert(b) {
        if (!b) throw new Error("Assertion failed");
    }
    function mixin(to, from) {
        Object.getOwnPropertyNames(from).forEach(function(name) {
            Object.defineProperty(to, name, Object.getOwnPropertyDescriptor(from, name));
        });
        return to;
    }
    function getWrapperConstructor(node) {
        var nativePrototype = node.__proto__ || Object.getPrototypeOf(node);
        var wrapperConstructor = constructorTable.get(nativePrototype);
        if (wrapperConstructor) return wrapperConstructor;
        var parentWrapperConstructor = getWrapperConstructor(nativePrototype);
        var GeneratedWrapper = createWrapperConstructor(parentWrapperConstructor);
        registerInternal(nativePrototype, GeneratedWrapper, node);
        return GeneratedWrapper;
    }
    function addForwardingProperties(nativePrototype, wrapperPrototype) {
        installProperty(nativePrototype, wrapperPrototype, true);
    }
    function registerInstanceProperties(wrapperPrototype, instanceObject) {
        installProperty(instanceObject, wrapperPrototype, false);
    }
    var isFirefox = /Firefox/.test(navigator.userAgent);
    var dummyDescriptor = {
        get: function() {},
        set: function(v) {},
        configurable: true,
        enumerable: true
    };
    function installProperty(source, target, allowMethod) {
        Object.getOwnPropertyNames(source).forEach(function(name) {
            if (name in target) return;
            if (isFirefox) {
                source.__lookupGetter__(name);
            }
            var descriptor;
            try {
                descriptor = Object.getOwnPropertyDescriptor(source, name);
            } catch (ex) {
                descriptor = dummyDescriptor;
            }
            var getter, setter;
            if (allowMethod && typeof descriptor.value === "function") {
                target[name] = function() {
                    return this.impl[name].apply(this.impl, arguments);
                };
                return;
            }
            getter = function() {
                return this.impl[name];
            };
            if (descriptor.writable || descriptor.set) {
                setter = function(value) {
                    this.impl[name] = value;
                };
            }
            Object.defineProperty(target, name, {
                get: getter,
                set: setter,
                configurable: descriptor.configurable,
                enumerable: descriptor.enumerable
            });
        });
    }
    function register(nativeConstructor, wrapperConstructor, opt_instance) {
        var nativePrototype = nativeConstructor.prototype;
        registerInternal(nativePrototype, wrapperConstructor, opt_instance);
    }
    function registerInternal(nativePrototype, wrapperConstructor, opt_instance) {
        var wrapperPrototype = wrapperConstructor.prototype;
        assert(constructorTable.get(nativePrototype) === undefined);
        constructorTable.set(nativePrototype, wrapperConstructor);
        addForwardingProperties(nativePrototype, wrapperPrototype);
        if (opt_instance) registerInstanceProperties(wrapperPrototype, opt_instance);
    }
    function registerObject(object, opt_nativeConstructor) {
        var nativePrototype = opt_nativeConstructor ? opt_nativeConstructor.prototype : Object.getPrototypeOf(object);
        var superWrapperConstructor = getWrapperConstructor(nativePrototype);
        var GeneratedWrapper = createWrapperConstructor(superWrapperConstructor);
        registerInternal(nativePrototype, GeneratedWrapper, object);
        return GeneratedWrapper;
    }
    function createWrapperConstructor(superWrapperConstructor) {
        function GeneratedWrapper(node) {
            superWrapperConstructor.call(this, node);
        }
        GeneratedWrapper.prototype = Object.create(superWrapperConstructor.prototype);
        return GeneratedWrapper;
    }
    function registerHTMLElement(tagName) {
        var element = document.createElement(tagName);
        if (element.constructor === HTMLElement || element instanceof HTMLUnknownElement) {
            return;
        }
        registerObject(element);
    }
    function wrap(node) {
        if (node === null) return null;
        assert(node instanceof Node || node instanceof Event);
        var wrapper = wrapperTable.get(node);
        if (!wrapper) {
            var wrapperConstructor = getWrapperConstructor(node);
            wrapper = new wrapperConstructor(node);
            wrapperTable.set(node, wrapper);
        }
        return wrapper;
    }
    function unwrap(wrapper) {
        if (wrapper === null) return null;
        assert(wrapper instanceof WrapperEventTarget || wrapper instanceof WrapperEvent);
        return wrapper.impl;
    }
    function rewrap(node, wrapper) {
        if (wrapper === null) return;
        assert(node instanceof Node || node instanceof Event);
        assert(wrapper === undefined || wrapper instanceof WrapperNode);
        wrapperTable.set(node, wrapper);
    }
    exports.mixin = mixin;
    exports.wrap = wrap;
    exports.unwrap = unwrap;
    exports.rewrap = rewrap;
    exports.wrappers = {
        register: register,
        registerHTMLElement: registerHTMLElement,
        registerObject: registerObject
    };
})(this);

(function(exports) {
    "use strict";
    function forwardElement(node) {
        while (node && node.nodeType !== Node.ELEMENT_NODE) {
            node = node.nextSibling;
        }
        return node;
    }
    function backwardsElement(node) {
        while (node && node.nodeType !== Node.ELEMENT_NODE) {
            node = node.previousSibling;
        }
        return node;
    }
    var ParentNodeInterface = {
        get firstElementChild() {
            return forwardElement(this.firstChild);
        },
        get lastElementChild() {
            return backwardsElement(this.lastChild);
        },
        get childElementCount() {
            var count = 0;
            for (var child = this.firstElementChild; child; child = child.nextElementSibling) {
                count++;
            }
            return count;
        },
        get children() {
            var wrapperList = new WrapperNodeList();
            var i = 0;
            for (var child = this.firstElementChild; child; child = child.nextElementSibling) {
                wrapperList[i++] = child;
            }
            wrapperList.length = i;
            return wrapperList;
        }
    };
    var ChildNodeInterface = {
        get nextElementSibling() {
            return forwardElement(this.nextSibling);
        },
        get previousElementSibling() {
            return backwardsElement(this.nextSibling);
        }
    };
    var SelectorsInterface = {
        querySelector: function(s) {
            return wrap(this.impl.querySelector(s));
        },
        querySelectorAll: function(s) {
            return wrapNodeList(this.impl.querySelectorAll(s));
        }
    };
    function addWrapGetter(wrapperConstructor, name) {
        Object.defineProperty(wrapperConstructor.prototype, name, {
            get: function() {
                return wrap(this.impl[name]);
            },
            configurable: true,
            enumerable: true
        });
    }
    function addWrapNodeListMethod(wrapperConstructor, name) {
        wrapperConstructor.prototype[name] = function() {
            return wrapNodeList(this.impl[name].apply(this.impl, arguments));
        };
    }
    exports.addWrapGetter = addWrapGetter;
    exports.addWrapNodeListMethod = addWrapNodeListMethod;
    exports.ChildNodeInterface = ChildNodeInterface;
    exports.ParentNodeInterface = ParentNodeInterface;
    exports.SelectorsInterface = SelectorsInterface;
})(this);

(function(exports) {
    "use strict";
    var wrappedFuns = new SideTable();
    var listenersTable = new SideTable();
    var handledEventsTable = new SideTable();
    var targetTable = new SideTable();
    var currentTargetTable = new SideTable();
    var eventPhaseTable = new SideTable();
    var stopPropagationTable = new SideTable();
    var stopImmediatePropagationTable = new SideTable();
    function isShadowRoot(node) {
        return node instanceof WrapperShadowRoot;
    }
    function isInsertionPoint(node) {
        var localName = node.localName;
        return localName === "content" || localName === "shadow";
    }
    function isShadowHost(node) {
        return !!node.shadowRoot;
    }
    function calculateParent(node, context) {
        if (isShadowRoot(node)) return node.insertionPointParent || getHostForShadowRoot(node);
        var p = node.insertionPointParent;
        if (p) return p;
        if (context && isInsertionPoint(node)) {
            var parentNode = node.parentNode;
            if (parentNode && isShadowHost(parentNode)) {
                var trees = getShadowTrees(parentNode);
                var p = context.insertionPointParent;
                for (var i = 0; i < trees.length; i++) {
                    if (trees[i].contains(p)) return p;
                }
            }
        }
        return node.parentNode;
    }
    function retarget(node) {
        var stack = [];
        var ancestor = node;
        var targets = [];
        while (ancestor) {
            var context = null;
            if (isInsertionPoint(ancestor)) {
                context = topMostNotInsertionPoint(stack);
                var top = stack[stack.length - 1] || ancestor;
                stack.push(top);
            }
            if (!stack.length) stack.push(ancestor);
            var target = stack[stack.length - 1];
            targets.push({
                target: target,
                ancestor: ancestor
            });
            if (isShadowRoot(ancestor)) stack.pop();
            ancestor = calculateParent(ancestor, context);
        }
        return targets;
    }
    function topMostNotInsertionPoint(stack) {
        for (var i = stack.length - 1; i >= 0; i--) {
            if (!isInsertionPoint(stack[i])) return stack[i];
        }
        return null;
    }
    function adjustRelatedTarget(target, related) {
        while (target) {
            var stack = [];
            var ancestor = related;
            var last = undefined;
            while (ancestor) {
                var context = null;
                if (!stack.length) {
                    stack.push(ancestor);
                } else {
                    if (isInsertionPoint(ancestor)) {
                        context = topMostNotInsertionPoint(stack);
                        if (isDistributed(last)) {
                            var head = stack[stack.length - 1];
                            stack.push(head);
                        }
                    }
                }
                if (inSameTree(ancestor, target)) return stack[stack.length - 1];
                if (isShadowRoot(ancestor)) stack.pop();
                last = ancestor;
                ancestor = calculateParent(ancestor, context);
            }
            if (isShadowRoot(target)) target = getHostForShadowRoot(target); else target = target.parentNode;
        }
    }
    function isDistributed(node) {
        return node.insertionPointParent;
    }
    function inSameTree(a, b) {
        while (true) {
            if (a === b) return a !== null;
            if (a) a = a.parentNode;
            if (b) b = b.parentNode;
        }
    }
    function dispatchOriginalEvent(originalEvent) {
        if (handledEventsTable.get(originalEvent)) return;
        handledEventsTable.set(originalEvent, true);
        var target = wrap(originalEvent.target);
        var event = wrap(originalEvent);
        return dispatchEvent(event, target);
    }
    function dispatchEvent(event, originalWrapperTarget) {
        var type = event.type;
        var bubbles = event.bubbles;
        var ancestorChain = retarget(originalWrapperTarget);
        var i = ancestorChain.length - 1;
        var phase = Event.CAPTURING_PHASE;
        eventPhaseTable.set(event, phase);
        var propagationStopped = false;
        for (;!propagationStopped && i > 0; i--) {
            propagationStopped = invoke(ancestorChain[i], event, type, phase);
        }
        phase = Event.AT_TARGET;
        eventPhaseTable.set(event, phase);
        if (!propagationStopped) {
            propagationStopped = invoke(ancestorChain[0], event, type, phase);
            i++;
        }
        if (bubbles) {
            phase = Event.BUBBLING_PHASE;
            eventPhaseTable.set(event, phase);
            for (;!propagationStopped && i < ancestorChain.length; i++) {
                propagationStopped = invoke(ancestorChain[i], event, type, phase);
            }
        }
        phase = Event.NONE;
        eventPhaseTable.set(event, phase);
        currentTargetTable.set(event, null);
        return event.defaultPrevented;
    }
    function invoke(tuple, event, type, phase) {
        var target = tuple.target;
        var currentTarget = tuple.ancestor;
        var listeners = listenersTable.get(currentTarget);
        if (!listeners) return;
        var anyRemoved = false;
        targetTable.set(event, target);
        currentTargetTable.set(event, currentTarget);
        for (var i = 0; i < listeners.length; i++) {
            var listener = listeners[i];
            if (listener.removed) {
                anyRemoved = true;
                continue;
            }
            if (listener.type !== type || !listener.capture && phase === Event.CAPTURING_PHASE || listener.capture && phase === Event.BUBBLING_PHASE) {
                continue;
            }
            try {
                if (typeof listener.handler === "function") listener.handler.call(currentTarget, event); else listener.handler.handleEvent(event);
                if (stopImmediatePropagationTable.get(event)) return true;
            } catch (ex) {
                if (window.onerror) window.onerror(ex.message); else console.error(ex);
            }
        }
        if (anyRemoved) {
            var copy = listeners.slice();
            listeners.length = 0;
            for (var i = 0; i < copy.length; i++) {
                if (!copy[i].removed) listeners.push(copy[i]);
            }
        }
        return stopPropagationTable.get(event);
    }
    function Listener(type, handler, capture) {
        this.type = type;
        this.handler = handler;
        this.capture = Boolean(capture);
    }
    Listener.prototype = {
        equals: function(that) {
            return this.handler === that.handler && this.type === that.type && this.capture === that.capture;
        },
        get removed() {
            return this.handler === null;
        },
        remove: function() {
            this.handler = null;
        }
    };
    function WrapperEvent(original) {
        this.impl = original;
    }
    WrapperEvent.prototype = {
        get target() {
            return targetTable.get(this);
        },
        get currentTarget() {
            return currentTargetTable.get(this);
        },
        get eventPhase() {
            return eventPhaseTable.get(this);
        },
        stopPropagation: function() {
            stopPropagationTable.set(this, true);
        },
        stopImmediatePropagation: function() {
            stopPropagationTable.set(this, true);
            stopImmediatePropagationTable.set(this, true);
        }
    };
    wrappers.register(Event, WrapperEvent, document.createEvent("Event"));
    function WrapperEventTarget(original) {
        this.impl = original;
    }
    WrapperEventTarget.prototype = {
        addEventListener: function(type, fun, capture) {
            var listener = new Listener(type, fun, capture);
            var listeners = listenersTable.get(this);
            if (!listeners) {
                listeners = [];
                listenersTable.set(this, listeners);
            } else {
                for (var i = 0; i < listeners.length; i++) {
                    if (listener.equals(listeners[i])) return;
                }
            }
            listeners.push(listener);
            unwrap(this).addEventListener(type, dispatchOriginalEvent, true);
        },
        removeEventListener: function(type, fun, capture) {
            var listeners = listenersTable.get(this);
            if (!listeners) return;
            var listener = new Listener(type, fun, capture);
            for (var i = 0; listeners.length; i++) {
                if (listener.equals(listeners[i])) {
                    listeners[i].remove();
                    return;
                }
            }
        },
        dispatchEvent: function(event) {
            return dispatchEvent(event, this);
        }
    };
    if (typeof EventTarget !== "undefined") wrappers.register(EventTarget, WrapperEventTarget);
    exports.WrapperEvent = WrapperEvent;
    exports.WrapperEventTarget = WrapperEventTarget;
    exports.adjustRelatedTarget = adjustRelatedTarget;
})(this);

(function(exports) {
    "use strict";
    function WrapperMouseEvent(original) {
        WrapperEvent.call(this, original);
    }
    WrapperMouseEvent.prototype = Object.create(WrapperEvent.prototype);
    addWrapGetter(WrapperMouseEvent, "relatedTarget");
    wrappers.register(MouseEvent, WrapperMouseEvent, document.createEvent("MouseEvent"));
    exports.WrapperMouseEvent = WrapperMouseEvent;
})(this);

(function(exports) {
    "use strict";
    function assert(b) {
        if (!b) throw new Error("Assertion failed");
    }
    function collectNodes(node, parentNode, previousNode, nextNode) {
        if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
            if (node.parentNode) node.parentNode.removeChild(node);
            node.parentNode_ = parentNode;
            node.previousSibling_ = previousNode;
            node.nextSibling_ = nextNode;
            if (previousNode) previousNode.nextSibling_ = node;
            if (nextNode) nextNode.previousSibling_ = node;
            return [ node ];
        }
        var nodes = [];
        var firstChild;
        while (firstChild = node.firstChild) {
            node.removeChild(firstChild);
            nodes.push(firstChild);
            firstChild.parentNode_ = parentNode;
        }
        for (var i = 0; i < nodes.length; i++) {
            nodes[i].previousSibling_ = nodes[i - 1] || previousNode;
            nodes[i].nextSibling_ = nodes[i + 1] || nextNode;
        }
        if (previousNode) previousNode.nextSibling_ = nodes[0];
        if (nextNode) nextNode.previousSibling_ = nodes[nodes.length - 1];
        return nodes;
    }
    function unwrapNodesForInsertion(nodes) {
        if (nodes.length === 1) return unwrap(nodes[0]);
        var df = unwrap(document.createDocumentFragment());
        for (var i = 0; i < nodes.length; i++) {
            df.appendChild(unwrap(nodes[i]));
        }
        return df;
    }
    function removeAllChildNodes(wrapper) {
        var childWrapper = wrapper.firstChild;
        while (childWrapper) {
            assert(childWrapper.parentNode === wrapper);
            var nextSibling = childWrapper.nextSibling;
            var childNode = unwrap(childWrapper);
            childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = null;
            var parentNode = childNode.parentNode;
            if (parentNode) parentNode.removeChild(childNode);
            childWrapper = nextSibling;
        }
        wrapper.firstChild_ = wrapper.lastChild_ = null;
    }
    function resetNodePointers(oldWrapper, newWrapper) {
        var w, p;
        if (w = oldWrapper.previousSibling) w.nextSibling_ = newWrapper;
        if (w = oldWrapper.nextSibling) w.previousSibling_ = newWrapper;
        if (p = oldWrapper.parentNode) {
            if (p.firstChild === oldWrapper) p.firstChild_ = newWrapper;
            if (p.lastChild === oldWrapper) p.lastChild_ = newWrapper;
        }
        newWrapper.parentNode_ = p;
        newWrapper.nextSibling_ = oldWrapper.nextSibling;
        newWrapper.previousSibling_ = oldWrapper.previousSibling;
        newWrapper.firstChild_ = oldWrapper.firstChild;
        newWrapper.lastChild_ = oldWrapper.lastChild;
        oldWrapper.node = oldWrapper.nextSibling_ = oldWrapper.previousSibling_ = oldWrapper.firstChild_ = oldWrapper.lastChild_ = undefined;
    }
    function WrapperNode(original) {
        assert(original instanceof Node);
        WrapperEventTarget.call(this, original);
        this.parentNode_ = undefined;
        this.firstChild_ = undefined;
        this.lastChild_ = undefined;
        this.nextSibling_ = undefined;
        this.previousSibling_ = undefined;
    }
    WrapperNode.prototype = Object.create(WrapperEventTarget.prototype);
    mixin(WrapperNode.prototype, {
        appendChild: function(childWrapper) {
            assert(childWrapper instanceof WrapperNode);
            this.invalidateShadowRenderer();
            var previousNode = this.lastChild;
            var nextNode = null;
            var nodes = collectNodes(childWrapper, this, previousNode, nextNode);
            this.lastChild_ = nodes[nodes.length - 1];
            if (!previousNode) this.firstChild_ = nodes[0];
            this.impl.appendChild(unwrapNodesForInsertion(nodes));
            return childWrapper;
        },
        insertBefore: function(childWrapper, refWrapper) {
            if (!refWrapper) return this.appendChild(childWrapper);
            assert(childWrapper instanceof WrapperNode);
            assert(refWrapper instanceof WrapperNode);
            assert(refWrapper.parentNode === this);
            this.invalidateShadowRenderer();
            var previousNode = refWrapper.previousSibling;
            var nextNode = refWrapper;
            var nodes = collectNodes(childWrapper, this, previousNode, nextNode);
            if (this.firstChild === refWrapper) this.firstChild_ = nodes[0];
            var refNode = unwrap(refWrapper);
            var parentNode = refNode.parentNode;
            if (parentNode) parentNode.insertBefore(unwrapNodesForInsertion(nodes), refNode);
            return childWrapper;
        },
        removeChild: function(childWrapper) {
            assert(childWrapper instanceof WrapperNode);
            if (childWrapper.parentNode !== this) {
                throw new Error("NotFoundError");
            }
            this.invalidateShadowRenderer();
            if (this.firstChild === childWrapper) this.firstChild_ = childWrapper.nextSibling;
            if (this.lastChild === childWrapper) this.lastChild_ = childWrapper.previousSibling;
            if (childWrapper.previousSibling) childWrapper.previousSibling.nextSibling_ = childWrapper.nextSibling;
            if (childWrapper.nextSibling) childWrapper.nextSibling.previousSibling_ = childWrapper.previousSibling;
            childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = null;
            var childNode = unwrap(childWrapper);
            var parentNode = childNode.parentNode;
            if (parentNode) parentNode.removeChild(childNode);
            return childWrapper;
        },
        replaceChild: function(newChildWrapper, oldChildWrapper) {
            assert(newChildWrapper instanceof WrapperNode);
            assert(oldChildWrapper instanceof WrapperNode);
            if (oldChildWrapper.parentNode !== this) {
                throw new Error("NotFoundError");
            }
            this.invalidateShadowRenderer();
            var previousNode = oldChildWrapper.previousSibling;
            var nextNode = oldChildWrapper.nextSibling;
            if (nextNode === newChildWrapper) nextNode = newChildWrapper.nextSibling;
            var nodes = collectNodes(newChildWrapper, this, previousNode, nextNode);
            if (this.firstChild === oldChildWrapper) this.firstChild_ = nodes[0];
            if (this.lastChild === oldChildWrapper) this.lastChild_ = nodes[nodes.length - 1];
            oldChildWrapper.previousSibling_ = null;
            oldChildWrapper.nextSibling_ = null;
            oldChildWrapper.parentNode_ = null;
            var oldChildNode = unwrap(oldChildWrapper);
            if (oldChildNode.parentNode) {
                oldChildNode.parentNode.replaceChild(unwrapNodesForInsertion(nodes), oldChildNode);
            }
            return oldChildWrapper;
        },
        hasChildNodes: function() {
            return this.firstChild === null;
        },
        get parentNode() {
            return this.parentNode_ !== undefined ? this.parentNode_ : wrap(this.impl.parentNode);
        },
        get firstChild() {
            return this.firstChild_ !== undefined ? this.firstChild_ : wrap(this.impl.firstChild);
        },
        get lastChild() {
            return this.lastChild_ !== undefined ? this.lastChild_ : wrap(this.impl.lastChild);
        },
        get nextSibling() {
            return this.nextSibling_ !== undefined ? this.nextSibling_ : wrap(this.impl.nextSibling);
        },
        get previousSibling() {
            return this.previousSibling_ !== undefined ? this.previousSibling_ : wrap(this.impl.previousSibling);
        },
        get parentElement() {
            var p = this.parentNode;
            while (p && p.nodeType !== Node.ELEMENT_NODE) {
                p = p.parentNode;
            }
            return p;
        },
        get textContent() {
            var s = "";
            for (var child = this.firstChild; child; child = child.nextSibling) {
                s += child.textContent;
            }
            return s;
        },
        set textContent(textContent) {
            removeAllChildNodes(this);
            this.invalidateShadowRenderer();
            if (textContent !== "") {
                var textNode = this.impl.ownerDocument.createTextNode(textContent);
                this.appendChild(textNode);
            }
        },
        get childNodes() {
            var wrapperList = new WrapperNodeList();
            var i = 0;
            for (var child = this.firstChild; child; child = child.nextSibling) {
                wrapperList[i++] = child;
            }
            wrapperList.length = i;
            return wrapperList;
        },
        cloneNode: function(deep) {
            if (!this.invalidateShadowRenderer()) return wrap(this.impl.cloneNode(deep));
            var clone = wrap(this.impl.cloneNode(false));
            if (deep) {
                for (var child = this.firstChild; child; child = child.nextSibling) {
                    clone.appendChild(child.cloneNode(true));
                }
            }
            return clone;
        },
        contains: function(child) {
            if (child === this) return true;
            var parentNode = child.parentNode;
            if (!parentNode) return false;
            return this.contains(parentNode);
        }
    });
    addWrapGetter(WrapperNode, "ownerDocument");
    wrappers.register(Node, WrapperNode, document.createDocumentFragment());
    delete WrapperNode.prototype.querySelector;
    delete WrapperNode.prototype.querySelectorAll;
    WrapperNode.prototype = mixin(Object.create(WrapperEventTarget.prototype), WrapperNode.prototype);
    exports.WrapperNode = WrapperNode;
    exports.resetNodePointers = resetNodePointers;
})(this);

(function(exports) {
    "use strict";
    function WrapperCharacterData(node) {
        WrapperNode.call(this, node);
    }
    WrapperCharacterData.prototype = Object.create(WrapperNode.prototype);
    mixin(WrapperCharacterData.prototype, {
        get textContent() {
            return this.data;
        },
        set textContent(value) {
            this.data = value;
        }
    });
    mixin(WrapperCharacterData.prototype, ChildNodeInterface);
    wrappers.register(CharacterData, WrapperCharacterData, document.createTextNode(""));
    exports.WrapperCharacterData = WrapperCharacterData;
})(this);

(function(exports) {
    "use strict";
    function nonEnum(obj, prop) {
        Object.defineProperty(obj, prop, {
            enumerable: false
        });
    }
    function WrapperNodeList() {
        this.length = 0;
        nonEnum(this, "length");
    }
    WrapperNodeList.prototype = {
        item: function(index) {
            return this[index];
        }
    };
    nonEnum(WrapperNodeList.prototype, "item");
    function wrapNodeList(list) {
        var wrapperList = new WrapperNodeList();
        for (var i = 0, length = list.length; i < length; i++) {
            wrapperList[i] = wrap(list[i]);
        }
        wrapperList.length = length;
        return wrapperList;
    }
    exports.wrapNodeList = wrapNodeList;
    exports.WrapperNodeList = WrapperNodeList;
})(this);

(function(exports) {
    "use strict";
    var shadowRootTable = new SideTable();
    function WrapperElement(node) {
        WrapperNode.call(this, node);
    }
    WrapperElement.prototype = Object.create(WrapperNode.prototype);
    mixin(WrapperElement.prototype, {
        createShadowRoot: function() {
            var newShadowRoot = new WrapperShadowRoot(this);
            shadowRootTable.set(this, newShadowRoot);
            var renderer = new ShadowRenderer(this);
            this.invalidateShadowRenderer();
            return newShadowRoot;
        },
        get shadowRoot() {
            return shadowRootTable.get(this) || null;
        },
        setAttribute: function(name, value) {
            this.impl.setAttribute(name, value);
            this.invalidateShadowRenderer();
        }
    });
    mixin(WrapperElement.prototype, ChildNodeInterface);
    mixin(WrapperElement.prototype, ParentNodeInterface);
    mixin(WrapperElement.prototype, SelectorsInterface);
    [ "getElementsByTagName", "getElementsByTagNameNS", "getElementsByClassName" ].forEach(function(name) {
        addWrapNodeListMethod(WrapperElement, name);
    });
    wrappers.register(Element, WrapperElement);
    exports.WrapperElement = WrapperElement;
})(this);

(function(exports) {
    "use strict";
    var escapeRegExp = /&|<|"/g;
    function escapeReplace(c) {
        switch (c) {
          case "&":
            return "&amp;";

          case "<":
            return "&lt;";

          case '"':
            return "&quot;";
        }
    }
    function escape(s) {
        return s.replace(escapeRegExp, escapeReplace);
    }
    var voidElements = {
        area: true,
        base: true,
        br: true,
        col: true,
        command: true,
        embed: true,
        hr: true,
        img: true,
        input: true,
        keygen: true,
        link: true,
        meta: true,
        param: true,
        source: true,
        track: true,
        wbr: true
    };
    function getOuterHTML(node) {
        switch (node.nodeType) {
          case Node.ELEMENT_NODE:
            var tagName = node.tagName.toLowerCase();
            var s = "<" + tagName;
            var attrs = node.attributes;
            for (var i = 0, attr; attr = attrs[i]; i++) {
                s += " " + attr.name + '="' + escape(attr.value) + '"';
            }
            s += ">";
            if (voidElements[tagName]) return s;
            return s + getInnerHTML(node) + "</" + tagName + ">";

          case Node.TEXT_NODE:
            return escape(node.nodeValue);

          case Node.COMMENT_NODE:
            return "<!--" + escape(node.nodeValue) + "-->";

          default:
            console.error(node);
            throw new Error("not implemented");
        }
    }
    function getInnerHTML(node) {
        var s = "";
        for (var child = node.firstChild; child; child = child.nextSibling) {
            s += getOuterHTML(child);
        }
        return s;
    }
    function setInnerHTML(node, value, opt_tagName) {
        var tagName = opt_tagName || "div";
        node.textContent = "";
        var tempElement = unwrap(node.ownerDocument.createElement(tagName));
        tempElement.innerHTML = value;
        var firstChild;
        while (firstChild = tempElement.firstChild) {
            node.appendChild(wrap(firstChild));
        }
    }
    function WrapperHTMLElement(node) {
        WrapperElement.call(this, node);
    }
    WrapperHTMLElement.prototype = Object.create(WrapperElement.prototype);
    mixin(WrapperHTMLElement.prototype, {
        get innerHTML() {
            return getInnerHTML(this);
        },
        set innerHTML(value) {
            setInnerHTML(this, value, this.tagName);
        },
        get outerHTML() {
            return getOuterHTML(this);
        },
        set outerHTML(value) {
            if (!this.invalidateShadowRenderer()) {
                this.impl.outerHTML = value;
            } else {
                throw new Error("not implemented");
            }
        }
    });
    function getterRequiresRendering(name) {
        Object.defineProperty(WrapperHTMLElement.prototype, name, {
            get: function() {
                renderAllPending();
                return this.impl[name];
            },
            configurable: true,
            enumerable: true
        });
    }
    [ "clientHeight", "clientLeft", "clientTop", "clientWidth", "offsetHeight", "offsetLeft", "offsetTop", "offsetWidth", "scrollHeight", "scrollLeft", "scrollTop", "scrollWidth" ].forEach(getterRequiresRendering);
    function methodRequiresRendering(name) {
        Object.defineProperty(WrapperHTMLElement.prototype, name, {
            value: function() {
                renderAllPending();
                return this.impl[name].apply(this.impl, arguments);
            },
            configurable: true,
            enumerable: true
        });
    }
    [ "getBoundingClientRect", "getClientRects", "scrollIntoView" ].forEach(methodRequiresRendering);
    wrappers.register(HTMLElement, WrapperHTMLElement, document.createElement("span"));
    exports.WrapperHTMLElement = WrapperHTMLElement;
    exports.getInnerHTML = getInnerHTML;
    exports.setInnerHTML = setInnerHTML;
})(this);

(function(exports) {
    "use strict";
    function WrapperHTMLUnknownElement(node) {
        switch (node.tagName) {
          case "CONTENT":
            return new WrapperHTMLContentElement(node);

          case "SHADOW":
            return new WrapperHTMLShadowElement(node);

          case "TEMPLATE":
            return new WrapperHTMLTemplateElement(node);
        }
        WrapperHTMLElement.call(this, node);
    }
    WrapperHTMLUnknownElement.prototype = Object.create(WrapperHTMLElement.prototype);
    wrappers.register(HTMLUnknownElement, WrapperHTMLUnknownElement);
    exports.WrapperHTMLUnknownElement = WrapperHTMLUnknownElement;
})(this);

(function(exports) {
    "use strict";
    function WrapperHTMLContentElement(node) {
        WrapperHTMLElement.call(this, node);
    }
    WrapperHTMLContentElement.prototype = Object.create(WrapperHTMLElement.prototype);
    mixin(WrapperHTMLContentElement.prototype, {
        get select() {
            return this.getAttribute("select");
        },
        set select(value) {
            this.setAttribute("select", value);
            this.invalidateShadowRenderer();
        }
    });
    if (typeof HTMLContentElement !== "undefined") wrappers.register(HTMLContentElement, WrapperHTMLContentElement);
    exports.WrapperHTMLContentElement = WrapperHTMLContentElement;
})(this);

(function(exports) {
    "use strict";
    function WrapperHTMLShadowElement(node) {
        WrapperHTMLElement.call(this, node);
        this.olderShadowRoot_ = null;
    }
    WrapperHTMLShadowElement.prototype = Object.create(WrapperHTMLElement.prototype);
    mixin(WrapperHTMLShadowElement.prototype, {
        get olderShadowRoot() {
            return this.olderShadowRoot_;
        }
    });
    if (typeof HTMLShadowElement !== "undefined") wrappers.register(HTMLShadowElement, WrapperHTMLShadowElement);
    exports.WrapperHTMLShadowElement = WrapperHTMLShadowElement;
})(this);

(function(exports) {
    "use strict";
    var hasNative = typeof HTMLTemplateElement !== "undefined";
    var contentTable = new SideTable();
    var templateContentsOwnerTable = new SideTable();
    function getTemplateContentsOwner(doc) {
        if (!doc.defaultView) return doc;
        var d = templateContentsOwnerTable.get(doc);
        if (!d) {
            d = doc.implementation.createHTMLDocument("");
            while (d.lastChild) {
                d.removeChild(d.lastChild);
            }
            templateContentsOwnerTable.set(doc, d);
        }
        return d;
    }
    function extractContent(templateElement) {
        var doc = getTemplateContentsOwner(templateElement.ownerDocument);
        var df = doc.createDocumentFragment();
        var nextSibling;
        var child;
        while (child = templateElement.firstChild) {
            df.appendChild(child);
        }
        return df;
    }
    function WrapperHTMLTemplateElement(node) {
        WrapperHTMLElement.call(this, node);
    }
    WrapperHTMLTemplateElement.prototype = Object.create(WrapperHTMLElement.prototype);
    mixin(WrapperHTMLTemplateElement.prototype, {
        get content() {
            if (hasNative) return wrap(this.impl.content);
            var content = contentTable.get(this);
            if (!content) {
                content = extractContent(this);
                contentTable.set(this, content);
            }
            return content;
        },
        get innerHTML() {
            return getInnerHTML(this.content);
        },
        set innerHTML(value) {
            setInnerHTML(this.content, value);
            this.invalidateShadowRenderer();
        }
    });
    if (hasNative) wrappers.register(HTMLTemplateElement, WrapperHTMLTemplateElement);
    exports.WrapperHTMLTemplateElement = WrapperHTMLTemplateElement;
})(this);

(function(exports) {
    "use strict";
    var WrapperDocumentFragment = wrappers.registerObject(document.createDocumentFragment());
    mixin(WrapperDocumentFragment.prototype, ParentNodeInterface);
    mixin(WrapperDocumentFragment.prototype, SelectorsInterface);
    wrappers.registerObject(document.createTextNode(""));
    wrappers.registerObject(document.createComment(""));
    exports.WrapperDocumentFragment = WrapperDocumentFragment;
})(this);

(function(exports) {
    "use strict";
    var shadowHostTable = new SideTable();
    function WrapperShadowRoot(hostWrapper) {
        var node = unwrap(hostWrapper.impl.ownerDocument.createDocumentFragment());
        WrapperDocumentFragment.call(this, node);
        rewrap(node, this);
        var oldShadowRoot = hostWrapper.shadowRoot;
        nextOlderShadowTreeTable.set(this, oldShadowRoot);
        shadowHostTable.set(this, hostWrapper);
        hostWrapper.invalidateShadowRenderer();
    }
    WrapperShadowRoot.prototype = Object.create(WrapperDocumentFragment.prototype);
    mixin(WrapperShadowRoot.prototype, {
        get innerHTML() {
            return getInnerHTML(this);
        },
        set innerHTML(value) {
            setInnerHTML(this, value);
            this.invalidateShadowRenderer();
        },
        invalidateShadowRenderer: function() {
            return shadowHostTable.get(this).invalidateShadowRenderer();
        }
    });
    exports.WrapperShadowRoot = WrapperShadowRoot;
    exports.getHostForShadowRoot = function(node) {
        return shadowHostTable.get(node);
    };
})(this);

(function(exports) {
    "use strict";
    function assert(b) {
        if (!b) throw new Error("Assertion failed");
    }
    function updateWrapperUpAndSideways(wrapper) {
        wrapper.previousSibling_ = wrapper.previousSibling;
        wrapper.nextSibling_ = wrapper.nextSibling;
        wrapper.parentNode_ = wrapper.parentNode;
    }
    function updateWrapperDown(wrapper) {
        wrapper.firstChild_ = wrapper.firstChild;
        wrapper.lastChild_ = wrapper.lastChild;
    }
    function updateAllChildNodes(parentNodeWrapper) {
        assert(parentNodeWrapper instanceof WrapperNode);
        for (var childWrapper = parentNodeWrapper.firstChild; childWrapper; childWrapper = childWrapper.nextSibling) {
            updateWrapperUpAndSideways(childWrapper);
        }
        updateWrapperDown(parentNodeWrapper);
    }
    function removeAllChildNodes(parentNodeWrapper) {
        var parentNode = unwrap(parentNodeWrapper);
        updateAllChildNodes(parentNodeWrapper);
        parentNode.textContent = "";
    }
    function appendChild(parentNodeWrapper, childWrapper) {
        var parentNode = unwrap(parentNodeWrapper);
        var child = unwrap(childWrapper);
        if (child.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            updateAllChildNodes(childWrapper);
        } else {
            remove(childWrapper);
            updateWrapperUpAndSideways(childWrapper);
        }
        parentNodeWrapper.lastChild_ = parentNodeWrapper.lastChild;
        if (parentNodeWrapper.lastChild === parentNodeWrapper.firstChild) parentNodeWrapper.firstChild_ = parentNodeWrapper.firstChild;
        var lastChildWrapper = wrap(parentNode.lastChild);
        if (lastChildWrapper) {
            lastChildWrapper.nextSibling_ = lastChildWrapper.nextSibling;
        }
        parentNode.appendChild(child);
    }
    function removeChild(parentNodeWrapper, childWrapper) {
        var parentNode = unwrap(parentNodeWrapper);
        var child = unwrap(childWrapper);
        updateWrapperUpAndSideways(childWrapper);
        if (childWrapper.previousSibling) childWrapper.previousSibling.nextSibling_ = childWrapper;
        if (childWrapper.nextSibling) childWrapper.nextSibling.previousSibling_ = childWrapper;
        if (parentNodeWrapper.lastChild === childWrapper) parentNodeWrapper.lastChild_ = childWrapper;
        if (parentNodeWrapper.firstChild === childWrapper) parentNodeWrapper.firstChild_ = childWrapper;
        parentNode.removeChild(child);
    }
    function remove(nodeWrapper) {
        var node = unwrap(nodeWrapper);
        var parentNode = node.parentNode;
        if (parentNode) removeChild(wrap(parentNode), nodeWrapper);
    }
    var distributedChildNodesTable = new SideTable();
    var shadowDOMRendererTable = new SideTable();
    var nextOlderShadowTreeTable = new SideTable();
    var insertionPointParentTable = new SideTable();
    function distributeChildToInsertionPoint(child, insertionPoint) {
        getDistributedChildNodes(insertionPoint).push(child);
        insertionPointParentTable.set(child, insertionPoint);
    }
    function resetDistributedChildNodes(insertionPoint) {
        distributedChildNodesTable.set(insertionPoint, []);
    }
    function getDistributedChildNodes(insertionPoint) {
        return distributedChildNodesTable.get(insertionPoint);
    }
    function getChildNodesSnapshot(node) {
        var result = [], i = 0;
        for (var child = node.firstChild; child; child = child.nextSibling) {
            result[i++] = child;
        }
        return result;
    }
    function visit(tree, predicate, visitor) {
        var nodes = getChildNodesSnapshot(tree);
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (predicate(node)) {
                if (visitor(node) === false) return;
            } else {
                visit(node, predicate, visitor);
            }
        }
    }
    function distribute(tree, pool) {
        var anyRemoved = false;
        visit(tree, isActiveInsertionPoint, function(insertionPoint) {
            resetDistributedChildNodes(insertionPoint);
            for (var i = 0; i < pool.length; i++) {
                var node = pool[i];
                if (node === undefined) continue;
                if (matchesCriteria(node, insertionPoint)) {
                    distributeChildToInsertionPoint(node, insertionPoint);
                    pool[i] = undefined;
                    anyRemoved = true;
                }
            }
        });
        if (!anyRemoved) return pool;
        var newPool = [];
        for (var i = 0; i < pool.length; i++) {
            if (pool[i] !== undefined) newPool.push(pool[i]);
        }
        return newPool;
    }
    var selectorMatchRegExp = /^[*.:#[a-zA-Z_|]/;
    var allowedPseudoRegExp = new RegExp("^:(" + [ "link", "visited", "target", "enabled", "disabled", "checked", "indeterminate", "nth-child", "nth-last-child", "nth-of-type", "nth-last-of-type", "first-child", "last-child", "first-of-type", "last-of-type", "only-of-type" ].join("|") + ")");
    function oneOf(object, propertyNames) {
        for (var i = 0; i < propertyNames.length; i++) {
            if (propertyNames[i] in object) return propertyNames[i];
        }
    }
    var matchesSelector = oneOf(document.documentElement, [ "matchesSelector", "msMatchesSelector", "mozMatchesSelector", "webkitMatchesSelector" ]);
    function matchesCriteria(node, point) {
        var select = point.getAttribute("select");
        if (!select) return true;
        select = select.trim();
        if (!select) return true;
        if (node.nodeType !== Node.ELEMENT_NODE) return false;
        if (!selectorMatchRegExp.test(select)) return false;
        if (select[0] === ":" && !allowedPseudoRegExp.test(select)) return false;
        try {
            return node[matchesSelector](select);
        } catch (ex) {
            return false;
        }
    }
    var request = oneOf(window, [ "requestAnimationFrame", "mozRequestAnimationFrame", "webkitRequestAnimationFrame", "setTimeout" ]);
    var pendingDirtyRenderers = [];
    var renderTimer;
    function renderAllPending() {
        renderTimer = null;
        pendingDirtyRenderers.forEach(function(owner) {
            owner.render();
        });
        pendingDirtyRenderers = [];
    }
    function ShadowRenderer(host) {
        this.host = host;
        this.dirty = false;
        this.associateNode(host);
    }
    ShadowRenderer.prototype = {
        render: function() {
            if (!this.dirty) return;
            var host = this.host;
            this.treeComposition();
            var shadowDOM = host.shadowRoot;
            if (!shadowDOM) return;
            this.removeAllChildNodes(this.host);
            var shadowDOMChildNodes = getChildNodesSnapshot(shadowDOM);
            shadowDOMChildNodes.forEach(function(node) {
                this.renderNode(host, shadowDOM, node, false);
            }, this);
            this.dirty = false;
        },
        invalidate: function() {
            if (!this.dirty) {
                this.dirty = true;
                pendingDirtyRenderers.push(this);
                if (renderTimer) return;
                renderTimer = window[request](renderAllPending, 0);
            }
        },
        renderNode: function(visualParent, tree, node, isNested) {
            if (isShadowHost(node)) {
                this.appendChild(visualParent, node);
                var renderer = new ShadowRenderer(node);
                renderer.render();
            } else if (isInsertionPoint(node)) {
                this.renderInsertionPoint(visualParent, tree, node, isNested);
            } else if (isShadowInsertionPoint(node)) {
                this.renderShadowInsertionPoint(visualParent, tree, node);
            } else {
                this.renderAsAnyDomTree(visualParent, tree, node, isNested);
            }
        },
        renderAsAnyDomTree: function(visualParent, tree, child, isNested) {
            this.appendChild(visualParent, child);
            if (isShadowHost(child)) {
                render(child);
            } else {
                var parent = child;
                var logicalChildNodes = getChildNodesSnapshot(parent);
                logicalChildNodes.forEach(function(node) {
                    this.renderNode(parent, tree, node, isNested);
                }, this);
            }
        },
        renderInsertionPoint: function(visualParent, tree, insertionPoint, isNested) {
            var distributedChildNodes = getDistributedChildNodes(insertionPoint);
            if (distributedChildNodes.length) {
                this.removeAllChildNodes(insertionPoint);
                distributedChildNodes.forEach(function(child) {
                    if (isInsertionPoint(child) && isNested) this.renderInsertionPoint(visualParent, tree, child, isNested); else this.renderAsAnyDomTree(visualParent, tree, child, isNested);
                }, this);
            } else {
                this.renderFallbackContent(visualParent, insertionPoint);
            }
            this.remove(insertionPoint);
        },
        renderShadowInsertionPoint: function(visualParent, tree, shadowInsertionPoint) {
            var nextOlderTree = getNextOlderTree(tree);
            if (nextOlderTree) {
                insertionPointParentTable.set(nextOlderTree, shadowInsertionPoint);
                shadowInsertionPoint.olderShadowRoot_ = nextOlderTree;
                this.remove(shadowInsertionPoint);
                var shadowDOMChildNodes = getChildNodesSnapshot(nextOlderTree);
                shadowDOMChildNodes.forEach(function(node) {
                    this.renderNode(visualParent, nextOlderTree, node, true);
                }, this);
            } else {
                this.renderFallbackContent(visualParent, shadowInsertionPoint);
            }
        },
        renderFallbackContent: function(visualParent, fallbackHost) {
            var logicalChildNodes = getChildNodesSnapshot(fallbackHost);
            logicalChildNodes.forEach(function(node) {
                this.appendChild(visualParent, node);
            }, this);
        },
        treeComposition: function() {
            var shadowHost = this.host;
            var tree = shadowHost.shadowRoot;
            var pool = [];
            var shadowHostChildNodes = getChildNodesSnapshot(shadowHost);
            shadowHostChildNodes.forEach(function(child) {
                if (isInsertionPoint(child)) {
                    var reprojected = getDistributedChildNodes(child);
                    if (!reprojected || !reprojected.length) reprojected = getChildNodesSnapshot(child);
                    pool.push.apply(pool, reprojected);
                } else {
                    pool.push(child);
                }
            });
            var shadowInsertionPoint, point;
            while (tree) {
                shadowInsertionPoint = undefined;
                visit(tree, isActiveShadowInsertionPoint, function(point) {
                    shadowInsertionPoint = point;
                    return false;
                });
                point = shadowInsertionPoint;
                pool = distribute(tree, pool);
                if (point) {
                    var nextOlderTree = getNextOlderTree(tree);
                    if (!nextOlderTree) {
                        break;
                    } else {
                        tree = nextOlderTree;
                        assignShadowTreeToShadowInsertionPoint(tree, point);
                        continue;
                    }
                } else {
                    break;
                }
            }
        },
        appendChild: function(parent, child) {
            appendChild(parent, child);
            this.associateNode(child);
        },
        remove: function(node) {
            remove(node);
            this.associateNode(node);
        },
        removeAllChildNodes: function(parent) {
            removeAllChildNodes(parent);
        },
        associateNode: function(node) {
            shadowDOMRendererTable.set(node, this);
        }
    };
    function isInsertionPoint(node) {
        return node.tagName == "CONTENT";
    }
    function isActiveInsertionPoint(node) {
        return node.tagName === "CONTENT";
    }
    function isShadowInsertionPoint(node) {
        return node.tagName === "SHADOW";
    }
    function isActiveShadowInsertionPoint(node) {
        return node.tagName === "SHADOW";
    }
    function isShadowHost(shadowHost) {
        return !!shadowHost.shadowRoot;
    }
    function getNextOlderTree(tree) {
        return nextOlderShadowTreeTable.get(tree);
    }
    function getShadowTrees(host) {
        var trees = [];
        for (var tree = host.shadowRoot; tree; tree = nextOlderShadowTreeTable.get(tree)) {
            trees.push(tree);
        }
        return trees;
    }
    function assignShadowTreeToShadowInsertionPoint(tree, point) {}
    function render(host) {
        new ShadowRenderer(host).render();
    }
    WrapperNode.prototype.invalidateShadowRenderer = function() {
        var renderer = shadowDOMRendererTable.get(this);
        if (!renderer) return false;
        renderer.invalidate();
        return true;
    };
    WrapperHTMLContentElement.prototype.getDistributedNodes = function() {
        renderAllPending();
        return getDistributedChildNodes(this);
    };
    mixin(WrapperNode.prototype, {
        get insertionPointParent() {
            return insertionPointParentTable.get(this) || null;
        }
    });
    exports.ShadowRenderer = ShadowRenderer;
    exports.renderAllPending = renderAllPending;
    exports.nextOlderShadowTreeTable = nextOlderShadowTreeTable;
    exports.getShadowTrees = getShadowTrees;
    exports.visual = {
        removeAllChildNodes: removeAllChildNodes,
        appendChild: appendChild,
        removeChild: removeChild
    };
})(this);

(function(exports) {
    "use strict";
    var implementationTable = new SideTable();
    function WrapperDocument(node) {
        WrapperNode.call(this, node);
    }
    WrapperDocument.prototype = Object.create(WrapperNode.prototype);
    addWrapGetter(WrapperDocument, "documentElement");
    addWrapGetter(WrapperDocument, "body");
    addWrapGetter(WrapperDocument, "head");
    mixin(WrapperDocument.prototype, ParentNodeInterface);
    mixin(WrapperDocument.prototype, {
        get implementation() {
            var implementation = implementationTable.get(this);
            if (implementation) return implementation;
            implementation = new WrapperDOMImplementation(unwrap(this).implementation);
            implementationTable.set(this, implementation);
            return implementation;
        }
    });
    wrappers.register(Document, WrapperDocument, document.implementation.createHTMLDocument(""));
    exports.WrapperDocument = WrapperDocument;
    if (typeof HTMLDocument !== "undefined") wrappers.register(HTMLDocument, WrapperDocument);
    function wrapMethod(name) {
        var proto = Object.getPrototypeOf(document);
        var original = proto[name];
        proto[name] = function() {
            return wrap(original.apply(this, arguments));
        };
        WrapperDocument.prototype[name] = function() {
            return wrap(original.apply(this.impl, arguments));
        };
    }
    [ "getElementById", "querySelector", "createElement", "createElementNS", "createTextNode", "createDocumentFragment", "createEvent", "createEventNS" ].forEach(wrapMethod);
    function wrapNodeListMethod(name) {
        var proto = Object.getPrototypeOf(document);
        var original = proto[name];
        proto[name] = function() {
            return wrapNodeList(original.apply(this, arguments));
        };
        WrapperDocument.prototype[name] = function() {
            return wrapNodeList(original.apply(this.impl, arguments));
        };
    }
    [ "getElementsByTagName", "getElementsByTagNameNS", "getElementsByClassName", "querySelectorAll" ].forEach(wrapNodeListMethod);
    function wrapImplMethod(constructor, name) {
        constructor.prototype[name] = function() {
            return wrap(this.impl[name].apply(this.impl, arguments));
        };
    }
    function forwardImplMethod(constructor, name) {
        constructor.prototype[name] = function() {
            return this.impl[name].apply(this.impl, arguments);
        };
    }
    function WrapperDOMImplementation(node) {
        this.impl = node;
    }
    wrapImplMethod(WrapperDOMImplementation, "createDocumentType");
    wrapImplMethod(WrapperDOMImplementation, "createDocument");
    wrapImplMethod(WrapperDOMImplementation, "createHTMLDocument");
    forwardImplMethod(WrapperDOMImplementation, "hasFeature");
})(this);

(function() {
    var WebComponents = {
        preloadSelectors: [ "link[rel=component]", "script[src]", "link[rel=stylesheet]" ],
        preload: function(inDocument, inNext) {
            wc.cache = loader.cache;
            var nodes = inDocument.querySelectorAll(wc.preloadSelectors);
            nodes = Array.prototype.filter.call(nodes, function(n) {
                return n.localName !== "script" || n.ownerDocument !== document;
            });
            loader.loadAll(nodes, inNext, wc.eachPreload);
        },
        eachPreload: function(data, next, url, elt) {
            if (wc.isDocumentLink(elt)) {
                var document = makeDocument(data, url);
                elt.component = elt.__resource = loader.cache[url] = document;
                WebComponents.preload(document, next);
            } else {
                next();
            }
        },
        isDocumentLink: function(inElt) {
            return inElt.localName === "link" && inElt.getAttribute("rel") === "component";
        }
    };
    var wc = WebComponents;
    wc.preloadSelectors = wc.preloadSelectors.join(",");
    var makeDocument = function(inHTML, inUrl) {
        var doc = document.implementation.createHTMLDocument("component");
        doc.body.innerHTML = inHTML;
        doc._URL = inUrl;
        return doc;
    };
    loader = {
        cache: {},
        loadAll: function(inNodes, inNext, inEach) {
            if (!inNodes.length) {
                inNext();
            }
            var inflight = 0;
            function head(inElt) {
                inflight++;
                var url = path.nodeUrl(inElt);
                var resource = loader.cache[url];
                if (resource) {
                    inElt.__resource = resource;
                    tail();
                }
                xhr.load(url, function(err, resource, url) {
                    if (err) {
                        tail();
                    } else {
                        inElt.__resource = loader.cache[url] = resource;
                        each(resource, tail, url, inElt);
                    }
                });
            }
            function tail() {
                if (!--inflight) {
                    inNext();
                }
            }
            var each = inEach || tail;
            forEach(inNodes, head);
        }
    };
    var path = {
        nodeUrl: function(inNode) {
            return path.resolveNodeUrl(inNode, path.hrefOrSrc(inNode));
        },
        hrefOrSrc: function(inNode) {
            return inNode.getAttribute("href") || inNode.getAttribute("src");
        },
        resolveNodeUrl: function(inNode, inRelativeUrl) {
            return this.resolveUrl(this.documentUrlFromNode(inNode), inRelativeUrl);
        },
        documentUrlFromNode: function(inNode) {
            var d = inNode.ownerDocument;
            var url = d && (d._URL || d.URL || window.unwrap && unwrap(d)._URL) || "";
            url = url.split("#")[0];
            return url;
        },
        resolveUrl: function(inBaseUrl, inUrl) {
            if (this.isAbsUrl(inUrl)) {
                return inUrl;
            }
            return this.compressUrl(this.urlToPath(inBaseUrl) + inUrl);
        },
        isAbsUrl: function(inUrl) {
            return /(^data:)|(^http[s]?:)|(^\/)/.test(inUrl);
        },
        urlToPath: function(inBaseUrl) {
            var parts = inBaseUrl.split("/");
            parts.pop();
            parts.push("");
            return parts.join("/");
        },
        compressUrl: function(inUrl) {
            var parts = inUrl.split("/");
            for (var i = 0, p; i < parts.length; i++) {
                p = parts[i];
                if (p === "..") {
                    parts.splice(i - 1, 2);
                    i -= 2;
                }
            }
            return parts.join("/");
        }
    };
    var xhr = {
        async: true,
        ok: function(inRequest) {
            return inRequest.status >= 200 && inRequest.status < 300 || inRequest.status === 304;
        },
        load: function(url, next, nextContext) {
            var request = new XMLHttpRequest();
            request.open("GET", url + "?" + Math.random(), xhr.async);
            request.addEventListener("readystatechange", function(e) {
                if (request.readyState === 4) {
                    next.call(nextContext, !xhr.ok(request) && request, request.response, url);
                }
            });
            request.send();
        }
    };
    var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
    window.WebComponents = WebComponents;
    if (typeof CustomEvent !== "function") {
        var CustomEvent = function(inType) {
            var e = document.createEvent("HTMLEvents");
            e.initEvent(inType, true, true);
            return e;
        };
    }
    window.addEventListener("load", function() {
        WebComponents.preload(document, function() {
            var sdocument = window.wrap ? wrap(document) : document;
            sdocument.body.dispatchEvent(new CustomEvent("WebComponentsLoaded", {
                bubbles: true
            }));
        });
    });
})();

(function() {
    function register(inName, inOptions) {
        var definition = inOptions || {};
        if (!inName) {
            throw new Error("Name argument must not be empty");
        }
        definition.name = inName;
        if (!definition.prototype) {
            throw new Error("Options missing required prototype property");
        }
        definition.lifecycle = definition.lifecycle || {};
        definition.ancestry = ancestry(definition.extends);
        resolveTagName(definition);
        resolvePrototypeChain(definition);
        registerDefinition(inName, definition);
        definition.ctor = generateConstructor(definition);
        definition.ctor.prototype = definition.prototype;
        document.upgradeElements();
        return definition.ctor;
    }
    function ancestry(inExtends) {
        var extendee = registry[inExtends];
        if (extendee) {
            return ancestry(extendee.extends).concat([ extendee ]);
        }
        return [];
    }
    function resolveTagName(inDefinition) {
        var baseTag = inDefinition.extends;
        for (var i = 0, a; a = inDefinition.ancestry[i]; i++) {
            baseTag = a.is && a.tag;
        }
        inDefinition.tag = baseTag || inDefinition.name;
        if (baseTag) {
            inDefinition.is = inDefinition.name;
        }
    }
    function resolvePrototypeChain(inDefinition) {
        if (window.WrapperElement && !(inDefinition.prototype instanceof WrapperElement) || !Object.__proto__) {
            if (inDefinition.is) {
                var inst = domCreateElement(inDefinition.tag);
                var wrapperNative = Object.getPrototypeOf(inst);
                if (window.WrapperElement) {
                    inst = unwrap(inst);
                }
                var native = Object.getPrototypeOf(inst);
            } else {
                native = HTMLElement.prototype;
                if (window.WrapperElement) {
                    wrapperNative = WrapperHTMLUnknownElement.prototype;
                }
            }
        }
        inDefinition.native = native;
        if (window.WrapperElement && !(inDefinition.prototype instanceof WrapperElement)) {
            if (Object.__proto__) {
                var p = inDefinition.prototype, pp;
                while (true) {
                    pp = Object.getPrototypeOf(p);
                    if (pp === native || pp == HTMLUnknownElement.prototype) {
                        break;
                    }
                    p = pp;
                }
                p.__proto__ = wrapperNative;
            } else {}
        }
    }
    function instantiate(inDefinition) {
        return upgrade(domCreateElement(inDefinition.tag), inDefinition);
    }
    function upgrade(inElement, inDefinition) {
        implement(inElement, inDefinition);
        if (inDefinition.is) {
            inElement.setAttribute("is", inDefinition.is);
        }
        inElement.__upgraded__ = true;
        created(inElement, inDefinition);
        return inElement;
    }
    function implement(inElement, inDefinition) {
        if (Object.__proto__) {
            inElement.__proto__ = inDefinition.prototype;
        } else {
            if (!Object.__proto__) {
                inElement.__proto__ = inDefinition.prototype;
            }
            customMixin(inElement, inDefinition.prototype, inDefinition.native);
        }
    }
    if (!console.group) {
        console.group = function(m) {
            console.log("[group] " + m);
        };
        console.groupEnd = function() {
            console.log("[end]");
        };
    }
    function customMixin(inTarget, inSrc, inNative) {
        var used = {};
        var p = inSrc;
        while (p !== inNative && p !== HTMLUnknownElement.prototype) {
            var keys = Object.getOwnPropertyNames(p);
            for (var i = 0, k; k = keys[i]; i++) {
                if (!used[k]) {
                    Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));
                    used[k] = 1;
                }
            }
            p = Object.getPrototypeOf(p);
        }
    }
    function created(inElement, inDefinition) {
        var readyCallback = inDefinition.lifecycle.readyCallback || inElement.readyCallback;
        if (readyCallback) {
            readyCallback.call(inElement);
        }
    }
    var registry = {};
    var registrySlctr = "";
    function registerDefinition(inName, inDefinition) {
        registry[inName] = inDefinition;
        registrySlctr += registrySlctr ? "," : "";
        if (inDefinition.extends) {
            registrySlctr += inDefinition.tag + "[is=" + inDefinition.is + "],";
        }
        registrySlctr += inName;
    }
    function generateConstructor(inDefinition) {
        return function() {
            return instantiate(inDefinition);
        };
    }
    function createElement(inTag) {
        var definition = registry[inTag];
        if (definition) {
            return new definition.ctor();
        }
        return domCreateElement(inTag);
    }
    function upgradeElement(inElement) {
        if (!inElement.__upgraded__) {
            var type = inElement.getAttribute("is") || inElement.localName;
            var definition = registry[type];
            return definition && upgrade(inElement, definition);
        }
    }
    function upgradeElements(inRoot, inSlctr) {
        var slctr = inSlctr || registrySlctr;
        if (slctr) {
            var root = inRoot || document;
            forEach(root.querySelectorAll(slctr), upgradeElement);
        }
    }
    var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
    function mixin(inObj) {
        var obj = inObj || {};
        for (var i = 1; i < arguments.length; i++) {
            var p = arguments[i];
            try {
                for (var n in p) {
                    copyProperty(n, p, obj);
                }
            } catch (x) {}
        }
        return obj;
    }
    function copyProperty(inName, inSource, inTarget) {
        var pd = getPropertyDescriptor(inSource, inName);
        Object.defineProperty(inTarget, inName, pd);
    }
    function getPropertyDescriptor(inObject, inName) {
        if (inObject) {
            var pd = Object.getOwnPropertyDescriptor(inObject, inName);
            return pd || getPropertyDescriptor(Object.getPrototypeOf(inObject), inName);
        }
    }
    var domCreateElement = document.createElement.bind(document);
    document.register = register;
    document.upgradeElement = upgradeElement;
    document.upgradeElements = upgradeElements;
    document.createElement = createElement;
    window.mixin = mixin;
})();

(function() {
    var HTMLElementElement = function(inElement) {
        inElement.register = HTMLElementElement.prototype.register;
        parseElementElement(inElement);
        return inElement;
    };
    HTMLElementElement.prototype = {
        register: function(inMore) {
            if (inMore) {
                this.options.lifecycle = inMore.lifecycle;
                if (inMore.prototype) {
                    mixin(this.options.prototype, inMore.prototype);
                }
            }
        }
    };
    function parseElementElement(inElement) {
        var options = {
            name: "",
            "extends": null
        };
        takeAttributes(inElement, options);
        var base = HTMLElement.prototype;
        if (options.extends) {
            var archetype = document.createElement(options.extends);
            base = archetype.__proto__ || Object.getPrototypeOf(archetype);
        }
        options.prototype = Object.create(base);
        inElement.options = options;
        var script = inElement.querySelector("script,scripts");
        if (script) {
            executeComponentScript(script.textContent, inElement, options.name);
        }
        document.register(options.name, options);
    }
    function takeAttributes(inElement, inDictionary) {
        for (var n in inDictionary) {
            var a = inElement.attributes[n];
            if (a) {
                inDictionary[n] = a.value;
            }
        }
    }
    function executeComponentScript(inScript, inContext, inName) {
        context = inContext;
        var owner = context.ownerDocument;
        var code = "__componentScript('" + inName + "', function(){" + inScript + "});" + "\n//@ sourceURL=" + (owner._URL || owner.URL) + "\n";
        eval(code);
    }
    var context;
    window.__componentScript = function(inName, inFunc) {
        inFunc.call(context);
    };
    window.HTMLElementElement = HTMLElementElement;
})();

(function() {
    var sdocument = window.wrap ? wrap(document) : document;
    var componentParser = {
        selectors: [ "link[rel=component]", "link[rel=stylesheet]", "script[src]", "script", "style", "element" ],
        map: {
            link: "parseLink",
            script: "parseScript",
            element: "parseElement",
            style: "parseStyle"
        },
        parse: function(inDocument) {
            if (inDocument) {
                document.upgradeElements(inDocument);
                var elts = inDocument.querySelectorAll(cp.selectors);
                forEach(elts, function(e) {
                    cp[cp.map[e.localName]](e);
                });
                document.upgradeElements(inDocument);
            }
        },
        parseLink: function(inLinkElt) {
            if (this.isDocumentLink(inLinkElt)) {
                cp.parse(inLinkElt.__resource);
            } else {}
        },
        isDocumentLink: function(inElt) {
            return inElt.localName === "link" && inElt.getAttribute("rel") === "component";
        },
        parseScript: function(inScriptElt) {
            if (inScriptElt.ownerDocument === sdocument) {
                return;
            }
            if (inScriptElt.parentNode.localName === "element") {
                return;
            }
            var code = inScriptElt.__resource || inScriptElt.textContent;
            if (code) {
                eval(code);
            }
        },
        parseStyle: function(inStyleElt) {
            document.querySelector("head").appendChild(inStyleElt);
        },
        parseElement: function(inElementElt) {
            new HTMLElementElement(inElementElt);
        }
    };
    var cp = componentParser;
    var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
    if (typeof CustomEvent !== "function") {
        var CustomEvent = function(inType) {
            var e = document.createEvent("HTMLEvents");
            e.initEvent(inType, true, true);
            return e;
        };
    }
    function bootstrap() {
        setTimeout(function() {
            componentParser.parse(document);
            sdocument.body.dispatchEvent(new CustomEvent("WebComponentsReady", {
                bubbles: true
            }));
        }, 0);
    }
    if (window.WebComponents) {
        sdocument.addEventListener("WebComponentsLoaded", bootstrap);
    } else {
        window.addEventListener("load", bootstrap);
    }
})();

(function(global) {
    "use strict";
    function ArraySet() {
        this.entries = [];
    }
    ArraySet.prototype = {
        add: function(key) {
            if (this.entries.indexOf(key) >= 0) return;
            this.entries.push(key);
        },
        "delete": function(key) {
            var i = this.entries.indexOf(key);
            if (i < 0) return;
            this.entries.splice(i, 1);
        },
        first: function() {
            return this.entries[0];
        },
        get size() {
            return this.entries.length;
        }
    };
    function UIDSet() {
        this.entries = {};
        this.size = 0;
    }
    UIDSet.prototype = {
        add: function(key) {
            if (this.entries[key.__UID__] !== undefined) return;
            this.entries[key.__UID__] = key;
            this.size++;
        },
        "delete": function(key) {
            if (this.entries[key.__UID__] === undefined) return;
            this.entries[key.__UID__] = undefined;
            this.size--;
        }
    };
    function Heap(scoreFunction, populate) {
        this.scoreFunction = scoreFunction;
        this.content = populate || [];
        if (this.content.length) this.build();
    }
    Heap.prototype = {
        get size() {
            return this.content.length;
        },
        build: function() {
            var lastNonLeaf = Math.floor(this.content.length / 2) - 1;
            for (var i = lastNonLeaf; i >= 0; i--) this.sinkDown(i);
        },
        push: function(element) {
            this.content.push(element);
            this.bubbleUp(this.content.length - 1);
        },
        pop: function() {
            var result = this.content[0];
            var end = this.content.pop();
            if (this.content.length) {
                this.content[0] = end;
                this.sinkDown(0);
            }
            return result;
        },
        "delete": function(element) {
            var len = this.content.length;
            for (var i = 0; i < len; i++) {
                if (this.content[i] == element) {
                    var end = this.content.pop();
                    if (i != len - 1) {
                        this.content[i] = end;
                        if (this.scoreFunction(end) < this.scoreFunction(node)) this.bubbleUp(i); else this.sinkDown(i);
                    }
                    return;
                }
            }
        },
        bubbleUp: function(n) {
            var element = this.content[n];
            while (n > 0) {
                var parentN = Math.floor((n + 1) / 2) - 1, parent = this.content[parentN];
                if (this.scoreFunction(element) <= this.scoreFunction(parent)) break;
                this.content[parentN] = element;
                this.content[n] = parent;
                n = parentN;
            }
        },
        sinkDown: function(n) {
            var length = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);
            do {
                var child2N = (n + 1) * 2;
                var child1N = child2N - 1;
                var swap = null;
                var swapScore = elemScore;
                if (child1N < length) {
                    var child1 = this.content[child1N], child1Score = this.scoreFunction(child1);
                    if (child1Score > elemScore) {
                        swap = child1N;
                        swapScore = child1Score;
                    }
                }
                if (child2N < length) {
                    var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);
                    if (child2Score > swapScore) swap = child2N;
                }
                if (swap != null) {
                    this.content[n] = this.content[swap];
                    this.content[swap] = element;
                    n = swap;
                }
            } while (swap != null);
        }
    };
    function Variable(stayFunc) {
        this.stayFunc = stayFunc;
        this.methods = new ArraySet();
    }
    Variable.prototype = {
        freeMethod: function() {
            return this.methods.first();
        }
    };
    function Method(constraint, variable) {
        this.constraint = constraint;
        this.variable = variable;
    }
    function Constraint(planner) {
        this.planner = planner;
        this.methods = [];
    }
    Constraint.prototype = {
        addMethod: function(variable) {
            var method = new Method(this, variable);
            this.methods.push(method);
            method.__UID__ = this.planner.methodUIDCounter++;
            return method;
        },
        reset: function() {
            this.methods.forEach(function(method) {
                method.variable.methods.add(method);
            });
        },
        remove: function() {
            this.methods.forEach(function(method) {
                method.variable.methods.delete(method);
            });
        }
    };
    function Planner() {
        this.variables = [];
        this.constraints = [];
        this.variableUIDCounter = 1;
        this.methodUIDCounter = 1;
    }
    Planner.prototype = {
        addVariable: function(stayFunc) {
            var variable = new Variable(stayFunc);
            variable.__UID__ = this.variableUIDCounter++;
            this.variables.push(variable);
            return variable;
        },
        addConstraint: function() {
            var constraint = new Constraint(this);
            this.constraints.push(constraint);
            return constraint;
        },
        removeConstraint: function(constraint) {
            var index = this.constraints.indexOf(constraint);
            if (index < 0) return;
            constraint.remove();
            this.constraints.splice(index, 1);
            this.constraints.forEach(function(constraint) {
                constraint.reset();
            });
            this.variables = this.variables.filter(function(variable) {
                return variable.methods.size;
            });
        },
        getPlan: function() {
            this.variables.forEach(function(variable) {
                variable.priority = variable.stayFunc();
            });
            this.constraints.forEach(function(constraint) {
                constraint.reset();
            });
            var methods = [];
            var free = [];
            var overconstrained = new UIDSet();
            this.variables.forEach(function(variable) {
                var methodCount = variable.methods.size;
                if (methodCount > 1) overconstrained.add(variable); else if (methodCount == 1) free.push(variable);
            });
            free = new Heap(function(variable) {
                return variable.priority;
            }, free);
            while (free.size) {
                var lowest;
                do {
                    lowest = free.pop();
                } while (free.size && !lowest.methods.size);
                if (!lowest.methods.size) break;
                var method = lowest.freeMethod();
                var constraint = method.constraint;
                constraint.remove();
                constraint.methods.forEach(function(method) {
                    var variable = method.variable;
                    if (variable.methods.size == 1) {
                        overconstrained.delete(variable);
                        free.push(variable);
                    }
                });
                methods.push(method);
            }
            if (overconstrained.size) return undefined;
            return methods.reverse();
        }
    };
    global.Planner = Planner;
})(this);

(function(global) {
    "use strict";
    var hasObserve = typeof Object.observe == "function";
    function isIndex(s) {
        return +s === s >>> 0;
    }
    function toNumber(s) {
        return +s;
    }
    function isObject(obj) {
        return obj === Object(obj);
    }
    var createObject = "__proto__" in {} ? function(obj) {
        return obj;
    } : function(obj) {
        var proto = obj.__proto__;
        if (!proto) return obj;
        var newObject = Object.create(proto);
        Object.getOwnPropertyNames(obj).forEach(function(name) {
            Object.defineProperty(newObject, name, Object.getOwnPropertyDescriptor(obj, name));
        });
        return newObject;
    };
    function ensureMapSetForEach() {
        if (Map.prototype.forEach && Set.prototype.forEach) return;
        var keyMap = new WeakMap();
        function getKeyMap(obj) {
            var map = keyMap.get(obj);
            if (!map) {
                map = Object.create(null);
                keyMap.set(obj, map);
            }
            return map;
        }
        var objectKeys = new WeakMap();
        var numberKeys = Object.create(null);
        var stringKeys = Object.create(null);
        var uidCounter = 4;
        function getUid(key) {
            if (key === null) return "$0";
            var keys, uid;
            switch (typeof key) {
              case "undefined":
                return "$1";

              case "boolean":
                return "$" + (key + 2);

              case "object":
              case "function":
                uid = objectKeys.get(key);
                if (!uid) {
                    uid = "$" + uidCounter++;
                    objectKeys.set(key, uid);
                }
                return uid;

              case "number":
                keys = numberKeys;
                break;

              case "string":
                keys = stringKeys;
                break;
            }
            uid = keys[key];
            if (!uid) {
                uid = "$" + uidCounter++;
                keys[key] = uid;
            }
            return uid;
        }
        var MapSet = Map.prototype.set;
        var MapDelete = Map.prototype.delete;
        var SetAdd = Set.prototype.add;
        var SetDelete = Set.prototype.delete;
        Map.prototype.set = function(key, value) {
            var uid = getUid(key);
            var keyMap = getKeyMap(this);
            keyMap[uid] = key;
            return MapSet.call(this, key, value);
        };
        Map.prototype.delete = function(key) {
            var uid = getUid(key);
            var keyMap = getKeyMap(this);
            delete keyMap[uid];
            return MapDelete.call(this, key);
        };
        Map.prototype.forEach = function(f, opt_this) {
            var keyMap = getKeyMap(this);
            for (var uid in keyMap) {
                var key = keyMap[uid];
                var value = this.get(key);
                f.call(opt_this || this, value, key, this);
            }
        };
        Set.prototype.add = function(key) {
            var uid = getUid(key);
            var keyMap = getKeyMap(this);
            keyMap[uid] = key;
            return SetAdd.call(this, key);
        };
        Set.prototype.delete = function(key) {
            var uid = getUid(key);
            var keyMap = getKeyMap(this);
            delete keyMap[uid];
            return SetDelete.call(this, key);
        };
        Set.prototype.forEach = function(f, opt_this) {
            var keyMap = getKeyMap(this);
            for (var uid in keyMap) {
                var key = keyMap[uid];
                f.call(opt_this || this, key, key, this);
            }
        };
        Map.getValueSet = function(map) {
            var set = new Set();
            map.forEach(function(value, key) {
                set.add(value);
            });
            return set;
        };
    }
    function polyfillMapSet(global) {
        function Map() {
            this.values_ = [];
            this.keys_ = [];
        }
        Map.prototype = {
            get: function(key) {
                return this.values_[this.keys_.indexOf(key)];
            },
            set: function(key, value) {
                var index = this.keys_.indexOf(key);
                if (index < 0) index = this.keys_.length;
                this.keys_[index] = key;
                this.values_[index] = value;
            },
            has: function(key) {
                return this.keys_.indexOf(key) >= 0;
            },
            "delete": function(key) {
                var index = this.keys_.indexOf(key);
                if (index < 0) return false;
                this.keys_.splice(index, 1);
                this.values_.splice(index, 1);
                return true;
            },
            forEach: function(f, opt_this) {
                for (var i = 0; i < this.keys_.length; i++) f.call(opt_this || this, this.values_[i], this.keys_[i], this);
            },
            get size() {
                return this.keys_.length;
            }
        };
        function Set() {
            this.keys_ = [];
        }
        Set.prototype = {
            add: function(key) {
                if (this.keys_.indexOf(key) < 0) this.keys_.push(key);
            },
            has: function(key) {
                return this.keys_.indexOf(key) >= 0;
            },
            "delete": function(key) {
                var index = this.keys_.indexOf(key);
                if (index < 0) return false;
                this.keys_.splice(index, 1);
                return true;
            },
            forEach: function(f, opt_this) {
                for (var i = 0; i < this.keys_.length; i++) f.call(opt_this || this, this.keys_[i], this.keys_[i], this);
            },
            get size() {
                return this.keys_.length;
            }
        };
        Map.getValueSet = function(map) {
            var set = new Set();
            set.keys_ = map.values_.slice();
            return set;
        };
        global.Map = Map;
        global.Set = Set;
    }
    if (typeof Map === "function" && typeof Set === "function" && typeof WeakMap === "function") ensureMapSetForEach(); else polyfillMapSet(global);
    var pathIndentPart = "[$a-z0-9_]+[$a-z0-9_\\d]*";
    var pathRegExp = new RegExp("^" + "(?:#?" + pathIndentPart + ")?" + "(?:" + "(?:\\." + pathIndentPart + ")" + ")*" + "$", "i");
    function isPathValid(s) {
        if (typeof s != "string") return false;
        s = s.replace(/\s/g, "");
        if (s == "") return true;
        if (s[0] == ".") return false;
        return pathRegExp.test(s);
    }
    function Path(s) {
        if (s.trim() == "") return this;
        if (isIndex(s)) {
            this.push(String(s));
            return this;
        }
        s.split(/\./).filter(function(part) {
            return part;
        }).forEach(function(part) {
            this.push(part);
        }, this);
    }
    Path.prototype = createObject({
        __proto__: [],
        toString: function() {
            return this.join(".");
        },
        walkPropertiesFrom: function(val, f, that) {
            var caughtException;
            var prop;
            for (var i = 0; i < this.length + 1; i++) {
                prop = this[i];
                f.call(that, prop, val, i);
                if (i == this.length || val === null || val === undefined) val = undefined; else val = val[prop];
            }
        }
    });
    var MAX_DIRTY_CHECK_CYCLES = 1e3;
    function ChangeSummary(externalCallback) {
        var observing = true;
        var isDisconnecting = false;
        var isDelivering = false;
        var changesDelivered = false;
        var summaries;
        var internal = {
            objectObservers: new Map(),
            bindingPriorityCounter: 1,
            getObjectObserver: function(obj) {
                return this.objectObservers.get(obj);
            },
            getOrCreateObjectObserver: function(obj) {
                var observer = this.objectObservers.get(obj);
                if (!observer) {
                    observer = new ObjectObserver(this, obj);
                    this.objectObservers.set(obj, observer);
                }
                return observer;
            },
            removeObjectObserver: function(obj) {
                this.objectObservers.delete(obj);
            },
            nextBindingPriority: function() {
                return this.bindingPriorityCounter++;
            },
            addPathTracker: function(obj, pathTracker) {
                this.getOrCreateObjectObserver(obj).addPathTracker(pathTracker);
            },
            removePathTracker: function(obj, pathTracker) {
                this.getObjectObserver(obj).removePathTracker(pathTracker);
            },
            connect: function() {
                this.objectObservers.forEach(function(observer) {
                    observer.connect();
                });
            },
            disconnect: function() {
                this.objectObservers.forEach(function(observer, object) {
                    observer.disconnect();
                });
            },
            internalCallback: function(records) {
                if (!records || !records.length) {
                    console.error("Object.observe callback called with no records");
                    return;
                }
                try {
                    if (!isDelivering) this.activeObservers = new Set();
                    var changedObject;
                    var observer;
                    for (var i = 0; i < records.length; i++) {
                        var record = records[i];
                        if (changedObject !== record.object) {
                            changedObject = record.object;
                            observer = this.getObjectObserver(changedObject);
                            if (!observer) {
                                changedObject = undefined;
                                continue;
                            }
                            this.activeObservers.add(observer);
                        }
                        observer.addChangeRecord(record);
                    }
                    if (isDelivering) return;
                    isDelivering = true;
                    this.deliverSummaries();
                    isDelivering = false;
                } catch (ex) {
                    console.error(ex);
                }
            },
            dirtyCheck: function() {
                var cycles = 0;
                do {
                    try {
                        cycles++;
                        this.activeObservers = Map.getValueSet(this.objectObservers);
                        this.deliverSummaries();
                    } catch (ex) {
                        console.error(ex);
                    }
                } while (changesDelivered && cycles < MAX_DIRTY_CHECK_CYCLES);
            },
            resolveBindings: function() {
                var methods = this.planner.getPlan();
                if (!methods) console.error("Error: bindings are over-constrained");
                var changed = false;
                for (var i = 0; i < methods.length; i++) {
                    var method = methods[i];
                    var pathTracker = method.to;
                    if (!pathTracker.setValue(method.from.value)) break;
                    changed = true;
                    var observer = this.getOrCreateObjectObserver(pathTracker.object);
                    observer.addDirtyPath(pathTracker);
                    this.activeObservers.add(observer);
                }
                return changed;
            },
            deliverSummaries: function() {
                summaries = [];
                var shouldResolveBindings = false;
                this.activeObservers.forEach(function(observer) {
                    shouldResolveBindings = observer.checkPathValues() || shouldResolveBindings;
                });
                if (shouldResolveBindings) {
                    if (this.resolveBindings() && hasObserve) Object.deliverChangeRecords(internal.callback);
                }
                this.activeObservers.forEach(function(observer) {
                    observer.checkObjectsAndArrays();
                });
                this.activeObservers.forEach(function(observer) {
                    var summary = observer.produceSummary();
                    observer.reset();
                    if (summary) summaries.push(summary);
                });
                this.activeObservers = undefined;
                if (!summaries.length) summaries = undefined;
                if (isDisconnecting || !summaries) {
                    changesDelivered = false;
                    return;
                }
                externalCallback(summaries);
                summaries = undefined;
                changesDelivered = true;
            }
        };
        internal.callback = internal.internalCallback.bind(internal);
        if (hasObserve) {
            var register = {};
            Object.observe(register, internal.callback);
            Object.unobserve(register, internal.callback);
        }
        this.observeObject = function(obj) {
            if (!isObject(obj)) throw Error("Invalid attempt to observe non-object: " + obj);
            internal.getOrCreateObjectObserver(obj).observeObject();
        };
        this.unobserveObject = function(obj) {
            if (!isObject(obj)) throw Error("Invalid attempt to unobserve non-object: " + obj);
            var observer = internal.getObjectObserver(obj);
            if (!observer) return;
            observer.unobserveObject();
        };
        this.observeArray = function(arr) {
            if (!Array.isArray(arr)) throw Error("Invalid attempt to observe non-array: " + arr);
            internal.getOrCreateObjectObserver(arr).observeArray();
        };
        this.unobserveArray = function(arr) {
            if (!Array.isArray(arr)) return;
            var observer = internal.getObjectObserver(arr);
            if (!observer) return;
            observer.unobserveArray();
        };
        this.observePath = function(obj, pathString) {
            if (!isPathValid(pathString)) return undefined;
            var path = new Path(pathString);
            if (!path.length) return obj;
            if (!isObject(obj)) return undefined;
            var pathTracker = internal.getOrCreateObjectObserver(obj).observePath(path);
            return pathTracker.value;
        };
        this.unobservePath = function(obj, pathString) {
            if (!isPathValid(pathString)) return;
            var path = new Path(pathString);
            if (!path.length) return;
            if (!isObject(obj)) return;
            var observer = internal.getObjectObserver(obj);
            if (!observer) return;
            observer.unobservePath(path);
        };
        this.bind = function(obj1, pathString1, obj2, pathString2) {
            if (typeof global.Planner !== "function") throw Error("Binding requires Planner library");
            if (!isPathValid(pathString1) || !isPathValid(pathString2)) throw Error("Not implemented");
            var path1 = new Path(pathString1);
            var path2 = new Path(pathString2);
            if (!path1.length || !path2.length || !isObject(obj1) || !isObject(obj2)) throw Error("Not implemented");
            if (!internal.planner) internal.planner = new Planner();
            var pathTracker1 = internal.getOrCreateObjectObserver(obj1).observePath(path1, true);
            var pathTracker2 = internal.getOrCreateObjectObserver(obj2).observePath(path2, true);
            if (pathTracker2.bindings && tracker2.bindings.has(pathTracker1)) return;
            if (pathTracker1.bindings && pathTracker1.bindings.has(pathTracker2)) return;
            if (!pathTracker1.bindings) pathTracker1.bindings = new Map();
            if (!pathTracker1.variable) {
                var priority1 = internal.nextBindingPriority();
                pathTracker1.variable = internal.planner.addVariable(function() {
                    return pathTracker1.changed ? priority1 : Infinity;
                });
            }
            if (!pathTracker2.variable) {
                var priority2 = internal.nextBindingPriority();
                pathTracker2.variable = internal.planner.addVariable(function() {
                    return pathTracker2.changed ? priority2 : Infinity;
                });
            }
            var constraint = internal.planner.addConstraint();
            pathTracker1.bindings.set(pathTracker2, constraint);
            var toMethod = constraint.addMethod(pathTracker2.variable);
            var fromMethod = constraint.addMethod(pathTracker1.variable);
            toMethod.from = pathTracker1;
            toMethod.to = pathTracker2;
            toMethod.name = pathTracker2.path.toString() + "->" + pathTracker1.path.toString();
            fromMethod.from = pathTracker2;
            fromMethod.to = pathTracker1;
            toMethod.name = pathTracker1.path.toString() + "->" + pathTracker2.path.toString();
            if (pathTracker1.value === pathTracker2.value) return;
            if (pathTracker1.value === undefined) pathTracker1.setValue(pathTracker2.value); else pathTracker2.setValue(pathTracker1.value);
        };
        this.unbind = function(obj1, pathString1, obj2, pathString2) {
            throw Error("Not implemented");
        };
        this.deliver = function() {
            if (!observing) throw Error("Disconnected");
            if (hasObserve) Object.deliverChangeRecords(internal.callback); else internal.dirtyCheck();
        };
        this.disconnect = function() {
            if (!observing) return;
            isDisconnecting = true;
            this.deliver();
            isDisconnecting = false;
            internal.disconnect();
            observing = false;
            if (!summaries) return;
            var retval = summaries;
            summaries = undefined;
            return retval;
        };
        this.connect = function() {
            if (observing) return;
            internal.connect();
            observing = true;
        };
    }
    ChangeSummary.getValueAtPath = function(obj, pathString) {
        if (!isPathValid(pathString)) return undefined;
        var path = new Path(pathString);
        if (!path.length) return obj;
        if (!isObject(obj)) return;
        var retval;
        path.walkPropertiesFrom(obj, function(prop, value, i) {
            if (i == this.length) retval = value;
        }, path);
        return retval;
    };
    function internalSetValueAtPath(obj, path, value) {
        var changed = false;
        path.walkPropertiesFrom(obj, function(prop, m, i) {
            if (isObject(m) && i == path.length - 1) {
                changed = true;
                m[prop] = value;
            }
        });
        return changed;
    }
    ChangeSummary.setValueAtPath = function(obj, pathString, value) {
        if (!isPathValid(pathString)) return;
        var path = new Path(pathString);
        if (!path.length) return;
        if (!isObject(obj)) return;
        internalSetValueAtPath(obj, path, value);
    };
    ChangeSummary.applySplices = function(previous, current, splices) {
        splices.forEach(function(splice) {
            var spliceArgs = [ splice.index, splice.removed.length ];
            var addIndex = splice.index;
            while (addIndex < splice.index + splice.addedCount) {
                spliceArgs.push(current[addIndex]);
                addIndex++;
            }
            Array.prototype.splice.apply(previous, spliceArgs);
        });
    };
    function objectIsEmpty(object) {
        for (var prop in object) return false;
        return true;
    }
    function diffIsEmpty(diff) {
        return objectIsEmpty(diff.added) && objectIsEmpty(diff.removed) && objectIsEmpty(diff.changed);
    }
    function diffObjectFromOldObject(object, oldObject) {
        var added = {};
        var removed = {};
        var changed = {};
        var oldObjectHas = {};
        for (var prop in oldObject) {
            var newValue = object[prop];
            if (newValue !== undefined && newValue === oldObject[prop]) continue;
            if (!(prop in object)) {
                removed[prop] = undefined;
                continue;
            }
            if (newValue !== oldObject[prop]) changed[prop] = newValue;
        }
        for (var prop in object) {
            if (prop in oldObject) continue;
            added[prop] = object[prop];
        }
        if (Array.isArray(object) && object.length !== oldObject.length) changed.length = object.length;
        return {
            added: added,
            removed: removed,
            changed: changed
        };
    }
    function copyObject(object, opt_copy) {
        var copy = opt_copy || (Array.isArray(object) ? [] : {});
        for (var prop in object) {
            copy[prop] = object[prop];
        }
        if (Array.isArray(object)) copy.length = object.length;
        return copy;
    }
    function ObjectTracker(object) {
        this.object = object;
        this.changed = false;
        this.diff = undefined;
        this.oldValues = undefined;
        this.reset(true);
    }
    ObjectTracker.prototype = {
        check: function(changeRecords) {
            var diff;
            var oldValues;
            if (hasObserve) {
                if (!changeRecords) return false;
                oldValues = {};
                diff = diffObjectFromChangeRecords(this.object, changeRecords, oldValues);
            } else {
                oldValues = this.oldObject;
                diff = diffObjectFromOldObject(this.object, this.oldObject);
            }
            if (diffIsEmpty(diff)) return false;
            this.diff = diff;
            this.oldValues = oldValues;
            this.changed = true;
            return true;
        },
        summarize: function(summary, oldValues) {
            summary.added = this.changed ? this.diff.added : {};
            summary.removed = this.changed ? this.diff.removed : {};
            summary.changed = this.changed ? this.diff.changed : {};
            copyObject(this.oldValues, oldValues);
        },
        reset: function(force) {
            if (!hasObserve && (force || this.diff)) this.oldObject = copyObject(this.object);
            this.changed = false;
            this.diff = undefined;
            this.oldValues = undefined;
        }
    };
    function ArrayTracker(array) {
        this.array = array;
        this.changed = false;
        this.splices = undefined;
        this.reset(true);
    }
    ArrayTracker.prototype = {
        check: function(changeRecords) {
            var splices;
            if (hasObserve) {
                if (!changeRecords) return false;
                var oldValues = {};
                var diff = diffObjectFromChangeRecords(this.array, changeRecords, oldValues);
                splices = projectArraySplices(this.array, diff, oldValues);
            } else {
                splices = calcSplices(this.array, 0, this.array.length, this.oldArray, 0, this.oldArray.length);
            }
            if (!splices.length) return false;
            this.splices = splices;
            this.changed = true;
            return true;
        },
        summarize: function(summary) {
            summary.splices = this.splices ? this.splices : [];
        },
        reset: function(force) {
            if (!hasObserve && (force || this.splices)) this.oldArray = this.array.slice();
            this.changed = false;
            this.splices = undefined;
        }
    };
    function PathTracker(object, path, pathString, internal) {
        this.object = object;
        this.path = path;
        this.pathString = pathString;
        this.observed = path.length > 1 ? new Array(path.length - 2) : undefined;
        this.changed = false;
        this.oldValue = undefined;
        this.bound = false;
        this.reporting = false;
        this.bindings = undefined;
        this.variable = undefined;
        this.internal = internal;
        this.reset(true);
    }
    var hasEval = false;
    try {
        var f = new Function("", "return true;");
        hasEval = f();
    } catch (ex) {}
    var pathTrackerCheck;
    if (hasObserve) {
        pathTrackerCheck = function() {
            var newValue;
            this.path.walkPropertiesFrom(this.object, function(prop, value, i) {
                if (i === this.path.length) {
                    newValue = value;
                    return;
                }
                if (i === 0) return;
                var observed = this.observed[i - 1];
                if (value === observed) return;
                if (observed !== undefined) {
                    this.observed[i - 1] = observed = undefined;
                    var stillObserving = false;
                    for (var j = 0; j < this.observed.length; j++) {
                        if (this.observed[j] === observed) {
                            stillObserving = true;
                            break;
                        }
                    }
                    if (!stillObserving) this.internal.removePathTracker(observed, this);
                }
                if (!isObject(value)) return;
                this.observed[i - 1] = observed = value;
                this.internal.addPathTracker(observed, this);
            }, this);
            return this.isChanged(newValue);
        };
    } else if (hasEval) {
        pathTrackerCheck = function() {
            if (!this.checkFunc) {
                var str = "";
                var partStr = "obj";
                var length = this.path.length;
                str += "if (obj";
                for (var i = 0; i < length - 1; i++) {
                    var part = '["' + this.path[i] + '"]';
                    partStr += part;
                    str += " && " + partStr;
                }
                str += ") ";
                partStr += '["' + this.path[length - 1] + '"]';
                str += "return " + partStr + "; else return undefined;";
                this.checkFunc = new Function("obj", str);
            }
            return this.isChanged(this.checkFunc(this.object));
        };
    } else {
        pathTrackerCheck = function() {
            var newValue;
            this.path.walkPropertiesFrom(this.object, function(prop, value, i) {
                if (i === this.path.length) newValue = value;
            }, this);
            return this.isChanged(newValue);
        };
    }
    PathTracker.prototype = {
        check: pathTrackerCheck,
        isChanged: function(newValue) {
            if (!this.changed) this.oldValue = this.value;
            this.value = newValue;
            return this.changed = this.oldValue !== this.value;
        },
        setValue: function(newValue) {
            var changed = internalSetValueAtPath(this.object, this.path, newValue);
            if (!changed) return false;
            this.isChanged(newValue);
            return changed;
        },
        summarize: function(summary, oldValues) {
            summary.pathChanged[this.pathString] = this.value;
            oldValues[this.pathString] = this.oldValue;
        },
        reset: function(force) {
            if (force) this.check();
            this.oldValue = undefined;
            this.changed = false;
        },
        destroy: function() {
            this.object = undefined;
            this.reset(true);
        }
    };
    function ObjectObserver(internal, object) {
        this.internal = internal;
        this.object = object;
        this.objectTracker = undefined;
        this.arrayTracker = undefined;
        this.pathTrackers = undefined;
        this.pathTrackerMap = undefined;
        this.changeRecords = undefined;
        this.dirtyPathTrackers = undefined;
        this.connect();
    }
    ObjectObserver.prototype = {
        observeObject: function() {
            this.objectTracker = this.objectTracker || new ObjectTracker(this.object);
        },
        unobserveObject: function() {
            this.objectTracker = undefined;
            this.destroyIfEmpty();
        },
        observeArray: function() {
            this.arrayTracker = this.arrayTracker || new ArrayTracker(this.object);
        },
        unobserveArray: function() {
            this.arrayTracker = undefined;
            this.destroyIfEmpty();
        },
        addPathTracker: function(pathTracker, opt_pathString) {
            if (!this.pathTrackers) {
                this.pathTrackers = [];
                this.pathTrackerMap = {};
            }
            if (opt_pathString) this.pathTrackerMap[opt_pathString] = pathTracker;
            this.pathTrackers.push(pathTracker);
        },
        removePathTracker: function(pathTracker) {
            if (!this.pathTrackers) return;
            this.pathTrackers.splice(this.pathTrackers.indexOf(pathTracker), 1);
            if (!this.pathTrackers.length) this.pathTrackers = undefined;
            this.destroyIfEmpty();
        },
        observePath: function(path, forBinding) {
            var pathTracker;
            var pathString = path.toString();
            if (this.pathTrackers && this.pathTrackerMap) pathTracker = this.pathTrackerMap[pathString];
            if (pathTracker) {
                pathTracker.check();
            } else {
                pathTracker = new PathTracker(this.object, path, pathString, this.internal);
                this.addPathTracker(pathTracker, pathString);
            }
            if (forBinding) pathTracker.bound = true; else pathTracker.reporting = true;
            return pathTracker;
        },
        unobservePath: function(path, forBinding) {
            if (!this.pathTrackerMap) return;
            var pathString = path.toString();
            var pathTracker = this.pathTrackerMap[pathString];
            if (!pathTracker) return;
            if (forBinding) pathTracker.bound = forBinding; else pathTracker.reporting = false;
            if (pathTracker.bound || pathTracker.reporting) return;
            pathTracker.destroy();
            delete this.pathTrackerMap[pathString];
            if (!Object.keys(this.pathTrackerMap).length) this.pathTrackerMap = undefined;
            this.pathTrackers.splice(this.pathTrackers.indexOf(pathTracker), 1);
            if (!this.pathTrackers.length) this.pathTrackers = undefined;
            this.destroyIfEmpty();
        },
        connect: function() {
            if (hasObserve) Object.observe(this.object, this.internal.callback);
            this.reset(true);
        },
        disconnect: function() {
            if (hasObserve) Object.unobserve(this.object, this.internal.callback);
        },
        destroyIfEmpty: function() {
            if (this.objectTracker || this.arrayTracker || this.pathTrackers) return;
            this.internal.removeObjectObserver(this.object);
            this.destroy();
        },
        destroy: function() {
            this.disconnect();
            this.internal = undefined;
        },
        addChangeRecord: function(changeRecord) {
            if (!this.changeRecords) this.changeRecords = [];
            this.changeRecords.push(changeRecord);
        },
        checkPathValues: function(changeRecords) {
            if (!this.internal) return;
            if (!this.pathTrackers) return;
            var bindingsAreDirty = false;
            for (var i = 0; i < this.pathTrackers.length; i++) {
                var pathTracker = this.pathTrackers[i];
                if (pathTracker.check()) {
                    var isThis = this.object === pathTracker.object;
                    var observer = isThis ? this : this.internal.getOrCreateObjectObserver(pathTracker.object);
                    observer.addDirtyPath(pathTracker);
                    if (!isThis) this.internal.activeObservers.add(observer);
                    if (pathTracker.variable) bindingsAreDirty = true;
                }
            }
            return bindingsAreDirty;
        },
        checkObjectsAndArrays: function() {
            if (!this.internal) return;
            if (this.objectTracker) this.objectTracker.check(this.changeRecords);
            if (this.arrayTracker) this.arrayTracker.check(this.changeRecords);
        },
        addDirtyPath: function(pathTracker) {
            if (!this.dirtyPathTrackers) this.dirtyPathTrackers = new Set();
            this.dirtyPathTrackers.add(pathTracker);
        },
        produceSummary: function() {
            if ((!this.objectTracker || !this.objectTracker.changed) && (!this.arrayTracker || !this.arrayTracker.changed) && !this.dirtyPathTrackers) return;
            var oldValues;
            var summary = {
                object: this.object
            };
            if (this.objectTracker || this.pathTrackerMap) {
                oldValues = {};
                summary.getOldValue = function(propOrPath) {
                    return oldValues[propOrPath];
                };
            }
            if (this.pathTrackerMap) summary.pathChanged = {};
            var changed = false;
            if (this.objectTracker) {
                this.objectTracker.summarize(summary, oldValues);
                changed = changed || this.objectTracker.changed;
            }
            if (this.arrayTracker) {
                this.arrayTracker.summarize(summary);
                changed = changed || this.arrayTracker.changed;
            }
            if (this.dirtyPathTrackers) {
                this.dirtyPathTrackers.forEach(function(pathTracker) {
                    if (!pathTracker.changed || !pathTracker.reporting) return;
                    pathTracker.summarize(summary, oldValues);
                    changed = true;
                });
            }
            if (changed) return summary;
        },
        reset: function(force) {
            if (this.objectTracker) this.objectTracker.reset(force);
            if (this.arrayTracker) this.arrayTracker.reset(force);
            var pathTrackersToReset = force ? this.pathTrackers : this.dirtyPathTrackers;
            if (pathTrackersToReset) pathTrackersToReset.forEach(function(pathTracker) {
                pathTracker.reset(force);
            });
            this.changeRecords = undefined;
            this.dirtyPathTrackers = undefined;
        }
    };
    var knownRecordTypes = {
        "new": true,
        updated: true,
        deleted: true
    };
    function diffObjectFromChangeRecords(object, changeRecords, oldValues) {
        var added = {};
        var removed = {};
        for (var i = 0; i < changeRecords.length; i++) {
            var record = changeRecords[i];
            if (!knownRecordTypes[record.type]) {
                console.error("Unknown changeRecord type: " + record.type);
                console.error(record);
                continue;
            }
            if (!(record.name in oldValues)) oldValues[record.name] = record.oldValue;
            if (record.type == "updated") continue;
            if (record.type == "new") {
                if (record.name in removed) delete removed[record.name]; else added[record.name] = true;
                continue;
            }
            if (record.name in added) {
                delete added[record.name];
                delete oldValues[record.name];
            } else {
                removed[record.name] = true;
            }
        }
        for (var prop in added) added[prop] = object[prop];
        for (var prop in removed) removed[prop] = undefined;
        var changed = {};
        for (var prop in oldValues) {
            if (prop in added || prop in removed) continue;
            var newValue = object[prop];
            if (oldValues[prop] !== newValue) changed[prop] = newValue;
        }
        return {
            added: added,
            removed: removed,
            changed: changed
        };
    }
    function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
        var rowCount = oldEnd - oldStart + 1;
        var columnCount = currentEnd - currentStart + 1;
        var distances = new Array(rowCount);
        for (var i = 0; i < rowCount; i++) {
            distances[i] = new Array(columnCount);
            distances[i][0] = i;
        }
        for (var j = 0; j < columnCount; j++) distances[0][j] = j;
        for (var i = 1; i < rowCount; i++) {
            for (var j = 1; j < columnCount; j++) {
                if (old[oldStart + i - 1] === current[currentStart + j - 1]) distances[i][j] = distances[i - 1][j - 1]; else {
                    var north = distances[i - 1][j] + 1;
                    var west = distances[i][j - 1] + 1;
                    distances[i][j] = north < west ? north : west;
                }
            }
        }
        return distances;
    }
    var EDIT_LEAVE = 0;
    var EDIT_UPDATE = 1;
    var EDIT_ADD = 2;
    var EDIT_DELETE = 3;
    function spliceOperationsFromEditDistances(distances) {
        var i = distances.length - 1;
        var j = distances[0].length - 1;
        var current = distances[i][j];
        var edits = [];
        while (i > 0 || j > 0) {
            if (i == 0) {
                edits.push(EDIT_ADD);
                j--;
                continue;
            }
            if (j == 0) {
                edits.push(EDIT_DELETE);
                i--;
                continue;
            }
            var northWest = distances[i - 1][j - 1];
            var west = distances[i - 1][j];
            var north = distances[i][j - 1];
            var min;
            if (west < north) min = west < northWest ? west : northWest; else min = north < northWest ? north : northWest;
            if (min == northWest) {
                if (northWest == current) {
                    edits.push(EDIT_LEAVE);
                } else {
                    edits.push(EDIT_UPDATE);
                    current = northWest;
                }
                i--;
                j--;
            } else if (min == west) {
                edits.push(EDIT_DELETE);
                i--;
                current = west;
            } else {
                edits.push(EDIT_ADD);
                j--;
                current = north;
            }
        }
        edits.reverse();
        return edits;
    }
    function sharedPrefix(arr1, arr2, searchLength) {
        for (var i = 0; i < searchLength; i++) if (arr1[i] !== arr2[i]) return i;
        return searchLength;
    }
    function sharedSuffix(arr1, arr2, searchLength) {
        var index1 = arr1.length;
        var index2 = arr2.length;
        var count = 0;
        while (count < searchLength && arr1[--index1] === arr2[--index2]) count++;
        return count;
    }
    function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
        var prefixCount = 0;
        var suffixCount = 0;
        var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
        if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);
        if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);
        currentStart += prefixCount;
        oldStart += prefixCount;
        currentEnd -= suffixCount;
        oldEnd -= suffixCount;
        if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];
        function newSplice(index, removed, addedCount) {
            return {
                index: index,
                removed: removed,
                addedCount: addedCount
            };
        }
        if (currentStart == currentEnd) {
            var splice = newSplice(currentStart, [], 0);
            while (oldStart < oldEnd) splice.removed.push(old[oldStart++]);
            return [ splice ];
        } else if (oldStart == oldEnd) return [ newSplice(currentStart, [], currentEnd - currentStart) ];
        var ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
        var splice = undefined;
        var splices = [];
        var index = currentStart;
        var oldIndex = oldStart;
        for (var i = 0; i < ops.length; i++) {
            switch (ops[i]) {
              case EDIT_LEAVE:
                if (splice) {
                    splices.push(splice);
                    splice = undefined;
                }
                index++;
                oldIndex++;
                break;

              case EDIT_UPDATE:
                if (!splice) splice = newSplice(index, [], 0);
                splice.addedCount++;
                index++;
                splice.removed.push(old[oldIndex]);
                oldIndex++;
                break;

              case EDIT_ADD:
                if (!splice) splice = newSplice(index, [], 0);
                splice.addedCount++;
                index++;
                break;

              case EDIT_DELETE:
                if (!splice) splice = newSplice(index, [], 0);
                splice.removed.push(old[oldIndex]);
                oldIndex++;
                break;
            }
        }
        if (splice) {
            splices.push(splice);
        }
        return splices;
    }
    function createInitialSplicesFromDiff(array, diff, oldValues) {
        var oldLength = "length" in oldValues ? toNumber(oldValues.length) : array.length;
        var lengthChangeSplice;
        if (array.length > oldLength) {
            lengthChangeSplice = {
                index: oldLength,
                removed: [],
                addedCount: array.length - oldLength
            };
        } else if (array.length < oldLength) {
            lengthChangeSplice = {
                index: array.length,
                removed: new Array(oldLength - array.length),
                addedCount: 0
            };
        }
        var indicesChanged = [];
        function addProperties(properties, oldValues) {
            Object.keys(properties).forEach(function(prop) {
                var index = toNumber(prop);
                if (isNaN(index) || index < 0 || index >= oldLength) return;
                var oldValue = oldValues[index];
                if (index < array.length) indicesChanged[index] = oldValue; else lengthChangeSplice.removed[index - array.length] = oldValues[index];
            });
        }
        addProperties(diff.added, oldValues);
        addProperties(diff.removed, oldValues);
        addProperties(diff.changed, oldValues);
        var splices = [];
        var current;
        for (var index in indicesChanged) {
            index = toNumber(index);
            if (current) {
                if (current.index + current.removed.length == index) {
                    current.removed.push(indicesChanged[index]);
                    continue;
                }
                current.addedCount = Math.min(array.length, current.index + current.removed.length) - current.index;
                splices.push(current);
                current = undefined;
            }
            current = {
                index: index,
                removed: [ indicesChanged[index] ]
            };
        }
        if (current) {
            current.addedCount = Math.min(array.length, current.index + current.removed.length) - current.index;
            if (lengthChangeSplice) {
                if (current.index + current.removed.length == lengthChangeSplice.index) {
                    current.addedCount = current.addedCount + lengthChangeSplice.addedCount;
                    current.removed = current.removed.concat(lengthChangeSplice.removed);
                    splices.push(current);
                } else {
                    splices.push(current);
                    splices.push(lengthChangeSplice);
                }
            } else {
                splices.push(current);
            }
        } else if (lengthChangeSplice) {
            splices.push(lengthChangeSplice);
        }
        return splices;
    }
    function projectArraySplices(array, diff, oldValues) {
        var splices = [];
        createInitialSplicesFromDiff(array, diff, oldValues).forEach(function(splice) {
            splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount, splice.removed, 0, splice.removed.length));
        });
        return splices;
    }
    global.ChangeSummary = ChangeSummary;
    function CallbackRouter() {
        var callbacksMap = typeof WeakMap == "function" ? new WeakMap() : new Map();
        function invokeCallbacks(summary) {
            var callbacks = callbacksMap.get(summary.object);
            if (!callbacks) return;
            if (callbacks.object && (summary.added || summary.removed || summary.changed)) {
                callbacks.object.forEach(function(callback) {
                    try {
                        callback(summary.added, summary.removed, summary.changed, summary.getOldValue, summary.object);
                    } catch (ex) {
                        console.log("Exception thrown during callback: " + ex);
                    }
                });
            }
            if (callbacks.array && summary.splices) {
                callbacks.array.forEach(function(callback) {
                    try {
                        callback(summary.splices, summary.object);
                    } catch (ex) {
                        console.log("Exception thrown during callback: " + ex);
                    }
                });
            }
            if (callbacks.path && summary.pathChanged) {
                Object.keys(callbacks.path).forEach(function(path) {
                    if (!summary.pathChanged.hasOwnProperty(path)) return;
                    callbacks.path[path].forEach(function(callback) {
                        try {
                            callback(summary.pathChanged[path], summary.getOldValue(path), summary.object, path);
                        } catch (ex) {
                            console.log("Exception thrown during callback: " + ex);
                        }
                    });
                });
            }
        }
        var observer = new ChangeSummary(function(summaries) {
            summaries.forEach(invokeCallbacks);
        });
        this.observeObject = function(object, callback) {
            var callbacks = callbacksMap.get(object);
            if (!callbacks) {
                callbacks = {};
                callbacksMap.set(object, callbacks);
            }
            if (!callbacks.object) {
                callbacks.object = new Set();
                observer.observeObject(object);
            }
            callbacks.object.add(callback);
        };
        this.unobserveObject = function(object, callback) {
            var callbacks = callbacksMap.get(object);
            if (!callbacks || !callbacks.object) return;
            callbacks.object.delete(callback);
            if (!callbacks.object.size) {
                observer.unobserveObject(object);
                callbacks.object = undefined;
            }
            if (!callbacks.object && !callbacks.array && !callbacks.path) callbacksMap.delete(object);
        };
        this.observeArray = function(array, callback) {
            if (!Array.isArray(array)) throw Error("Invalid attempt to observe non-array: " + arr);
            var callbacks = callbacksMap.get(array);
            if (!callbacks) {
                callbacks = {};
                callbacksMap.set(array, callbacks);
            }
            if (!callbacks.array) {
                callbacks.array = new Set();
                observer.observeArray(array);
            }
            callbacks.array.add(callback);
        };
        this.unobserveArray = function(array, callback) {
            if (!Array.isArray(array)) return;
            var callbacks = callbacksMap.get(array);
            if (!callbacks || !callbacks.array) return;
            callbacks.array.delete(callback);
            if (!callbacks.array.size) {
                observer.unobserveArray(array);
                callbacks.array = undefined;
            }
            if (!callbacks.object && !callbacks.array && !callbacks.path) callbacksMap.delete(array);
        };
        this.observePath = function(object, path, callback) {
            if (!isPathValid(path)) return undefined;
            if (path.trim() == "") return object;
            if (!isObject(object)) return undefined;
            var callbacks = callbacksMap.get(object);
            if (!callbacks) {
                callbacks = {};
                callbacksMap.set(object, callbacks);
            }
            if (!callbacks.path) callbacks.path = {};
            var pathCallbacks = callbacks.path[path];
            var retval;
            if (!pathCallbacks) {
                pathCallbacks = new Set();
                callbacks.path[path] = pathCallbacks;
                retval = observer.observePath(object, path);
            } else {
                retval = ChangeSummary.getValueAtPath(object, path);
            }
            pathCallbacks.add(callback);
            return retval;
        };
        this.unobservePath = function(object, path, callback) {
            if (!isPathValid(path) || !isObject(object)) return;
            var callbacks = callbacksMap.get(object);
            if (!callbacks || !callbacks.path) return;
            var pathCallbacks = callbacks.path[path];
            if (!pathCallbacks) return;
            pathCallbacks.delete(callback);
            if (!pathCallbacks.size) {
                observer.unobservePath(object, path);
                delete callbacks.path[path];
            }
            if (!Object.keys(callbacks.path).length) callbacks.path = undefined;
            if (!callbacks.object && !callbacks.array && !callbacks.path) callbacksMap.delete(object);
        };
        this.bind = function(obj1, path1, obj2, path2) {
            observer.bind(obj1, path1, obj2, path2);
        };
        this.unbind = function(obj1, path1, obj2, path2) {
            observer.unbind(obj1, path1, obj2, path2);
        };
        this.deliver = observer.deliver.bind(observer);
    }
    global.ChangeSummary.CallbackRouter = CallbackRouter;
})(this);

var createObject = "__proto__" in {} ? function(obj) {
    return obj;
} : function(obj) {
    var proto = obj.__proto__;
    if (!proto) return obj;
    var newObject = Object.create(proto);
    Object.getOwnPropertyNames(obj).forEach(function(name) {
        Object.defineProperty(newObject, name, Object.getOwnPropertyDescriptor(obj, name));
    });
    return newObject;
};

if (typeof document.createElement("div").hidden != "boolean") {
    Object.defineProperty(HTMLElement.prototype, "hidden", {
        get: function() {
            return this.hasAttribute("hidden");
        },
        set: function(b) {
            if (b) this.setAttribute("hidden", ""); else this.removeAttribute("hidden");
        },
        enumerable: true,
        configurable: true
    });
    var styleElement = document.createElement("style");
    styleElement.textContent = "[hidden] { display: none }";
    document.head.appendChild(styleElement);
}

var SideTable;

if (typeof WeakMap !== "undefined") {
    SideTable = WeakMap;
} else {
    SideTable = function(name) {
        this.name = "__$" + name + "$__";
    };
    SideTable.prototype = {
        set: function(key, value) {
            Object.defineProperty(key, this.name, {
                value: value,
                writable: true
            });
        },
        get: function(key) {
            return key[this.name];
        },
        "delete": function(key) {
            this.set(key, undefined);
        }
    };
}

function SideTableInherit(name) {
    this.map = new SideTable(name);
}

SideTableInherit.prototype = {
    set: function(key, value) {
        this.map.set(key, value);
    },
    get: function(key) {
        if (key === null) return undefined;
        var value = this.map.get(key);
        if (value !== undefined) return value;
        return this.get(Object.getPrototypeOf(key));
    },
    "delete": function(key) {
        this.map.delete(key);
    }
};

this.Model = function() {
    var router = new ChangeSummary.CallbackRouter();
    var queue = [];
    var notificationQueueIsRunning = false;
    return {
        enqueue: function(func) {
            queue.push(func);
        },
        notifyChanges: function() {
            if (notificationQueueIsRunning) return;
            notificationQueueIsRunning = true;
            router.deliver();
            while (queue.length > 0) {
                var f = queue.shift();
                f();
            }
            notificationQueueIsRunning = false;
        },
        getValueAtPath: ChangeSummary.getValueAtPath,
        setValueAtPath: ChangeSummary.setValueAtPath,
        observeObject: router.observeObject.bind(router),
        unobserveObject: router.unobserveObject.bind(router),
        observeArray: router.observeArray.bind(router),
        unobserveArray: router.unobserveArray.bind(router),
        observePath: router.observePath.bind(router),
        unobservePath: router.unobservePath.bind(router),
        bind: router.bind.bind(router),
        unbind: router.unbind.bind(router)
    };
}();

var ScriptValueBinding;

var DelegatedValueBinding;

(function() {
    "use strict";
    function isObject(value) {
        return Object(value) === value;
    }
    function toUint32(v) {
        return v >>> 0;
    }
    function isFunction(v) {
        return typeof v === "function";
    }
    function assert(v) {
        if (!v) throw new Error("Assertion failed");
    }
    ScriptValueBinding = function(model, path, observer) {
        this.model_ = null;
        this.path_ = path;
        this.observer_ = observer;
        this.boundCallback_ = this.scriptPropertyChanged.bind(this);
        this.setModel(model);
    };
    ScriptValueBinding.prototype = {
        unbind: function() {
            Model.unobservePath(this.model_, this.path_, this.boundCallback_);
        },
        scriptPropertyChanged: function(newValue) {
            if (isObject(newValue) && newValue.mutation) {
                return;
            }
            if (this.value_ !== newValue) {
                this.value_ = newValue;
                this.observer_.valueChanged(this);
            }
        },
        setModel: function(model) {
            Model.unobservePath(this.model_, this.path_, this.boundCallback_);
            this.model_ = model;
            var oldValue = this.value_;
            this.value_ = Model.observePath(this.model_, this.path_, this.boundCallback_);
            return this.value_ !== oldValue;
        },
        get value() {
            return this.value_;
        },
        set value(value) {
            Model.setValueAtPath(this.model_, this.path_, value);
        }
    };
    DelegatedValueBinding = function(model, delegate, bindingText, type, observer) {
        this.observer_ = observer;
        this.bindingText_ = bindingText;
        this.type_ = type;
        this.paths_ = [];
        this.bindings_ = [];
        this.toSourceFunction_ = null;
        this.toTargetFunction_ = null;
        this.setDelegate(model, delegate);
    };
    var ONE_WAY = 1;
    var TWO_WAY = 2;
    DelegatedValueBinding.Type = {
        ONE_WAY: ONE_WAY,
        TWO_WAY: TWO_WAY
    };
    DelegatedValueBinding.prototype = {
        unbind: function() {
            this.bindings_.forEach(function(binding) {
                binding.unbind();
            });
        },
        valueChanged: function(binding) {
            if (this.computeValue()) this.observer_.valueChanged(this);
        },
        setModel: function(model) {
            var changed = false;
            this.bindings_.forEach(function(binding) {
                changed = binding.setModel(model) || changed;
            });
            if (changed) return this.computeValue();
            return false;
        },
        setDelegate: function(model, delegate) {
            this.paths_ = [];
            this.bindings_ = [];
            if (!this.constructDelegate(delegate)) this.paths_.push(this.bindingText_);
            for (var i = 0; i < this.paths_.length; i++) {
                this.bindings_.push(new ScriptValueBinding(model, this.paths_[i], this));
            }
            return this.computeValue();
        },
        set value(value) {
            assert(this.type_ === TWO_WAY);
            this.bindings_[0].value = this.invokeToSource(value);
        },
        get value() {
            return this.value_;
        },
        constructDelegate: function(delegate) {
            if (!delegate || !isFunction(delegate)) return false;
            var result = delegate(this.bindingText_);
            if (!isObject(result)) return false;
            var pathValues = result[0];
            if (!isObject(pathValues)) return false;
            var count = toUint32(pathValues.length);
            if (!count) return false;
            for (var i = 0; i < count; i++) {
                var pathValue = pathValues[i];
                if (typeof pathValue !== "string") {
                    this.paths_ = [];
                    return false;
                }
                this.paths_.push(pathValue);
            }
            var toTargetFunction = result[1];
            if (isFunction(toTargetFunction)) this.toTargetFunction_ = toTargetFunction;
            var toSourceFunction = result[2];
            if (this.type_ === TWO_WAY && isFunction(toSourceFunction)) this.toSourceFunction_ = toSourceFunction;
            return true;
        },
        invokeToTarget: function() {
            if (!this.toTargetFunction_) return this.bindings_[0].value;
            assert(isFunction(this.toTargetFunction_));
            var args = this.bindings_.map(function(binding) {
                return binding.value;
            });
            return this.toTargetFunction_.apply(null, args);
        },
        invokeToSource: function(value) {
            if (!this.toSourceFunction_) return value;
            assert(isFunction(this.toSourceFunction_));
            return this.toSourceFunction_(value);
        },
        computeValue: function() {
            var newValue = this.invokeToTarget();
            if (this.value_ === newValue) return false;
            this.value_ = newValue;
            return true;
        }
    };
})();

var TextReplacementsBinding = function() {
    "use strict";
    var ONE_WAY = DelegatedValueBinding.Type.ONE_WAY;
    function assert(v) {
        if (!v) throw new Error("Assertion failed");
    }
    var TEXT = 0;
    var BINDING = 1;
    function Token(type, value) {
        this.type = type;
        this.value = value;
    }
    function parse(s) {
        var result = [];
        var length = s.length;
        var index = 0, lastIndex = 0;
        while (lastIndex < length) {
            index = s.indexOf("{{", lastIndex);
            if (index < 0) {
                result.push(new Token(TEXT, s.slice(lastIndex)));
                break;
            } else {
                if (index > 0 && lastIndex < index) {
                    result.push(new Token(TEXT, s.slice(lastIndex, index)));
                }
                lastIndex = index + 2;
                index = s.indexOf("}}", lastIndex);
                if (index < 0) {
                    var text = s.slice(lastIndex - 2);
                    var lastToken = result[result.length - 1];
                    if (lastToken && lastToken.type == TEXT) lastToken.value += text; else result.push(new Token(TEXT, text));
                    break;
                }
                var value = s.slice(lastIndex, index).trim();
                result.push(new Token(BINDING, value));
                lastIndex = index + 2;
            }
        }
        return result;
    }
    function TextReplacementsBinding(model, delegate, bindingText, observer) {
        this.observer_ = observer;
        this.value_ = "";
        this.bindingText_ = bindingText;
        this.bindings_ = [];
        this.tokens_ = parse(bindingText);
        this.bindPlaceHolders(model, delegate);
        this.computeValue();
    }
    TextReplacementsBinding.prototype = {
        unbind: function() {
            this.bindings_.forEach(function(binding) {
                binding.unbind();
            });
        },
        get value() {
            return this.value_;
        },
        valueIsSimpleNull: function() {
            return this.tokens_.length === 1 && this.bindings_.length === 1 && this.bindings_[0].value === null;
        },
        setModel: function(model) {
            var changed = false;
            for (var i = 0; i < this.bindings_.length; i++) {
                changed = this.bindings_[i].setModel(model) || changed;
            }
            if (changed) return this.computeValue();
            return false;
        },
        setDelegate: function(model, delegate) {
            var changed = false;
            for (var i = 0; i < this.bindings_.length; i++) {
                changed = this.bindings_[i].setDelegate(model, delegate) || changed;
            }
            if (changed) this.computeValue();
            return changed;
        },
        get bindingText() {
            return this.bindingText_;
        },
        valueChanged: function(binding) {
            if (this.computeValue()) this.observer_.valueChanged(this);
        },
        computeValue: function() {
            var newValue = "";
            var tokens = this.tokens_;
            var bindings = this.bindings_;
            var value;
            var bindingIndex = 0;
            for (var i = 0; i < this.tokens_.length; i++) {
                var token = tokens[i];
                if (token.type === TEXT) {
                    newValue += token.value;
                } else {
                    assert(bindingIndex < this.bindings_.length);
                    value = bindings[bindingIndex++].value;
                    if (value !== undefined) newValue += value;
                }
            }
            if (newValue !== this.value_) {
                this.value_ = newValue;
                return true;
            }
            return false;
        },
        bindPlaceHolders: function(model, delegate) {
            for (var i = 0; i < this.tokens_.length; i++) {
                if (this.tokens_[i].type === BINDING) {
                    this.bindings_.push(new DelegatedValueBinding(model, delegate, this.tokens_[i].value, ONE_WAY, this));
                }
            }
        }
    };
    return TextReplacementsBinding;
}();

var ElementAttributeBindings = function() {
    "use strict";
    function Binding(element, attributeName, bindingText) {
        this.element_ = element;
        this.attributeName_ = attributeName;
        this.binding_ = new TextReplacementsBinding(element.model, element.modelDelegate, bindingText, this);
    }
    Binding.prototype = {
        unbind: function() {
            this.binding_.unbind();
        },
        modelChanged: function(newModel) {
            if (this.binding_.setModel(newModel)) this.valueChanged(this.binding_);
        },
        modelDelegateChanged: function(newModelDelegate) {
            if (this.binding_.setDelegate(this.element_.model, newModelDelegate)) this.valueChanged(this.binding_);
        },
        valueChanged: function(binding) {
            if (binding.valueIsSimpleNull()) this.element_.removeAttribute(this.attributeName_); else this.element_.setAttribute(this.attributeName_, binding.value);
        },
        fire: function() {
            this.valueChanged(this.binding_);
        },
        get bindingText() {
            return this.binding_.bindingText;
        }
    };
    function ElementAttributeBindings() {
        this.attributeBindings_ = Object.create(null);
    }
    ElementAttributeBindings.prototype = {
        addBinding: function(element, attributeName, path) {
            this.removeBinding(attributeName);
            var binding = new Binding(element, attributeName, path);
            this.attributeBindings_[attributeName] = binding;
            binding.fire();
        },
        removeBinding: function(attributeName) {
            var binding = this.attributeBindings_[attributeName];
            if (binding) {
                binding.unbind();
                delete this.attributeBindings_[attributeName];
            }
        },
        modelChanged: function(newModel) {
            for (var attributeName in this.attributeBindings_) {
                this.attributeBindings_[attributeName].modelChanged(newModel);
            }
        },
        modelDelegateChanged: function(newModelDelegate) {
            for (var attributeName in this.attributeBindings_) {
                this.attributeBindings_[attributeName].modelDelegateChanged(newModelDelegate);
            }
        },
        bindingText: function(attributeName) {
            var binding = this.attributeBindings_[attributeName];
            return binding ? binding.bindingText : null;
        }
    };
    return ElementAttributeBindings;
}();

var modelChangedTable = new SideTableInherit("modelChanged");

var modelDelegateChangedTable = new SideTableInherit("modelDelegateChanged");

(function() {
    "use strict";
    var modelTable = new SideTable("model");
    var modelDelegateTable = new SideTable("modelDelegate");
    var textContentBindingTable = new SideTable("textContentBinding");
    var attributeBindingsTable = new SideTable("attributeBindings");
    function addBinding(attributeName, path) {
        var bindings = attributeBindingsTable.get(this);
        if (!bindings) {
            bindings = new ElementAttributeBindings();
            attributeBindingsTable.set(this, bindings);
        }
        bindings.addBinding(this, attributeName, path);
    }
    function removeBinding(attributeName) {
        var bindings = attributeBindingsTable.get(this);
        if (bindings) bindings.removeBinding(attributeName);
    }
    function makeTextObserver(textNode) {
        return {
            valueChanged: function(binding) {
                textValueChanged(textNode, binding);
            }
        };
    }
    function addTextBinding(path) {
        this.removeBinding();
        var binding = new TextReplacementsBinding(this.model, this.modelDelegate, path, makeTextObserver(this));
        textContentBindingTable.set(this, binding);
        textValueChanged(this, binding);
    }
    function removeTextBinding() {
        var binding = textContentBindingTable.get(this);
        if (binding) {
            binding.unbind();
            textContentBindingTable.delete(this);
        }
    }
    function hasOwnModel(node) {
        return modelTable.get(node) !== undefined;
    }
    function hasOwnModelDelegate(node) {
        return modelDelegateTable.get(node) !== undefined;
    }
    function hasBindings(node) {
        return attributeBindingsTable.get(node) !== undefined || textContentBindingTable.get(node) !== undefined;
    }
    function modelChanged() {
        if (hasBindings(this)) Model.enqueue(lazyModelChanged.bind(this));
        var f;
        for (var child = this.firstChild; child; child = child.nextSibling) {
            if (!hasOwnModel(child) && (f = modelChangedTable.get(child))) f.call(child);
        }
    }
    function modelDelegateChanged() {
        if (hasBindings(this)) Model.enqueue(lazyModelDelegateChanged.bind(this));
        var f;
        for (var child = this.firstChild; child; child = child.nextSibling) {
            if (!hasOwnModel(child) && (f = modelDelegateChangedTable.get(child))) f.call(child);
        }
    }
    function inheritedGetter(table) {
        return function() {
            for (var node = this; node; node = node.parentNode) {
                var value = table.get(node);
                if (value !== undefined) return value;
            }
            return undefined;
        };
    }
    function handleDomNodeInsertedOrRemoved(e) {
        var node = e.target;
        if (!hasOwnModel(node)) modelChangedTable.get(node).call(node);
    }
    function setupMutationListeners(node) {
        if (hasOwnModel(node) || hasOwnModelDelegate(node)) {
            node.addEventListener("DOMNodeInserted", handleDomNodeInsertedOrRemoved, true);
            node.addEventListener("DOMNodeRemoved", handleDomNodeInsertedOrRemoved, true);
        } else {
            node.removeEventListener("DOMNodeInserted", handleDomNodeInsertedOrRemoved, true);
            node.removeEventListener("DOMNodeRemoved", handleDomNodeInsertedOrRemoved, true);
        }
    }
    function setModel(model) {
        var oldModel = modelTable.get(this);
        if (oldModel === model) return;
        modelTable.set(this, model);
        setupMutationListeners(this);
        modelChangedTable.get(this).call(this, this);
    }
    function setModelDelegate(modelDelegate) {
        var oldModelDelegate = modelDelegateTable.get(this);
        if (oldModelDelegate === modelDelegate) return;
        modelDelegateTable.set(this, modelDelegate);
        setupMutationListeners(this);
        modelDelegateChangedTable.get(this).call(this, this);
    }
    function accessor(get, set) {
        return {
            get: get,
            set: set,
            enumerable: true,
            configurable: true
        };
    }
    var descriptor = {
        model: accessor(inheritedGetter(modelTable), setModel),
        modelDelegate: accessor(inheritedGetter(modelDelegateTable), setModelDelegate)
    };
    [ Element, Text, DocumentFragment ].forEach(function(ctor) {
        Object.defineProperties(ctor.prototype, descriptor);
        modelChangedTable.set(ctor.prototype, modelChanged);
        modelDelegateChangedTable.set(ctor.prototype, modelDelegateChanged);
    });
    function lazyModelChanged() {
        var bindings = attributeBindingsTable.get(this);
        if (bindings) bindings.modelChanged(this.model);
        var binding = textContentBindingTable.get(this);
        if (binding && binding.setModel(this.model)) textValueChanged(this, binding);
    }
    function lazyModelDelegateChanged() {
        var bindings = attributeBindingsTable.get(this);
        if (bindings) bindings.modelDelegateChanged(this.modelDelegate);
        var binding = textContentBindingTable.get(this);
        if (binding && binding.setDelegate(this.model, this.modelDelegate)) textValueChanged(this, binding);
    }
    Element.prototype.addBinding = addBinding;
    Element.prototype.removeBinding = removeBinding;
    Text.prototype.addBinding = addTextBinding;
    Text.prototype.removeBinding = removeTextBinding;
    Object.defineProperty(Attr.prototype, "bindingText", accessor(function() {
        var element = this.ownerElement;
        if (!element) return null;
        var bindings = attributeBindingsTable.get(element);
        return bindings ? bindings.bindingText(this.name) : null;
    }));
    Object.defineProperty(Text.prototype, "bindingText", accessor(function() {
        var binding = textContentBindingTable.get(this);
        return binding ? binding.bindingText : null;
    }));
    function textValueChanged(textNode, binding) {
        textNode.data = binding.value;
    }
})();

(function() {
    "use strict";
    function getEventForInputType(element) {
        switch (element.type) {
          case "checkbox":
            return "click";

          case "radio":
          case "select-multiple":
          case "select-one":
            return "change";

          default:
            return "input";
        }
    }
    var TWO_WAY = DelegatedValueBinding.Type.TWO_WAY;
    function InputBinding(element, path) {
        this.element_ = element;
        this.path_ = path;
        this.lastValue_ = undefined;
        this.binding_ = new DelegatedValueBinding(element.model, element.modelDelegate, path, TWO_WAY, this);
        this.boundUpdateBinding_ = this.updateBinding.bind(this);
        this.element_.addEventListener(getEventForInputType(this.element_), this.boundUpdateBinding_, true);
    }
    InputBinding.prototype = {
        unbind: function() {
            this.binding_.unbind();
            this.element_.removeEventListener(getEventForInputType(this.element_), this.boundUpdateBinding_, true);
        },
        setModel: function(newModel) {
            if (this.binding_.setModel(newModel)) this.valueChanged(this.binding_);
        },
        setDelegate: function(model, newDelegate) {
            if (this.binding_.setDelegate(model, newDelegate)) this.valueChanged(this.binding_);
        }
    };
    function ValueBinding(element, path) {
        InputBinding.call(this, element, path);
        this.valueChanged(this.binding_);
    }
    ValueBinding.prototype = createObject({
        __proto__: InputBinding.prototype,
        valueChanged: function(binding) {
            var newValue = binding.value;
            var stringValue = "";
            if (newValue != null) stringValue = String(newValue);
            if (stringValue === this.lastValue_) return;
            this.lastValue_ = stringValue;
            this.element_.value = stringValue;
        },
        updateBinding: function() {
            var value = this.element_.value;
            if (value !== this.lastValue_) {
                this.binding_.value = value;
                Model.notifyChanges();
            }
        }
    });
    function isNodeInDocument(node) {
        return node.ownerDocument.contains(node);
    }
    var filter = Array.prototype.filter.call.bind(Array.prototype.filter);
    function getAssociatedRadioButtons(element) {
        if (!isNodeInDocument(element)) return [];
        if (element.form) {
            return filter(element.form.elements, function(el) {
                return el != element && el.tagName == "INPUT" && el.type == "radio" && el.name == element.name;
            });
        } else {
            var radios = element.ownerDocument.querySelectorAll('input[type="radio"][name="' + element.name + '"]');
            return filter(radios, function(el) {
                return el != element && !el.form;
            });
        }
    }
    function CheckedBinding(element, path) {
        InputBinding.call(this, element, path);
        this.valueChanged(this.binding_);
    }
    CheckedBinding.prototype = createObject({
        __proto__: InputBinding.prototype,
        valueChanged: function(binding) {
            var newValue = binding.value;
            var boolValue = Boolean(newValue);
            if (boolValue === this.lastValue_) return;
            this.lastValue_ = boolValue;
            this.element_.checked = boolValue;
        },
        updateBinding: function() {
            var value = this.element_.checked;
            if (value !== this.lastValue_) {
                this.binding_.value = value;
                if (this.element_.tagName === "INPUT" && this.element_.type === "radio") {
                    getAssociatedRadioButtons(this.element_).forEach(function(r) {
                        var checkedBinding = checkedBindingTable.get(r);
                        if (checkedBinding) {
                            checkedBinding.binding_.value = false;
                        }
                    });
                }
                Model.notifyChanges();
            }
        }
    });
    var valueBindingTable = new SideTable("valueBinding");
    var checkedBindingTable = new SideTable("checkedBinding");
    Object.defineProperty(HTMLInputElement.prototype, "checkedBinding_", {
        get: function() {
            return checkedBindingTable.get(this);
        },
        set: function(value) {
            checkedBindingTable.set(this, value);
        }
    });
    HTMLInputElement.prototype.addValueBinding = function(path) {
        this.removeValueBinding();
        valueBindingTable.set(this, new ValueBinding(this, path));
    };
    HTMLInputElement.prototype.removeValueBinding = function() {
        var valueBinding = valueBindingTable.get(this);
        if (valueBinding) {
            valueBinding.unbind();
            valueBindingTable.delete(this);
        }
    };
    HTMLInputElement.prototype.addCheckedBinding = function(path) {
        this.removeCheckedBinding();
        checkedBindingTable.set(this, new CheckedBinding(this, path));
    };
    HTMLInputElement.prototype.removeCheckedBinding = function() {
        if (checkedBindingTable.get(this)) {
            checkedBindingTable.get(this).unbind();
            checkedBindingTable.delete(this);
        }
    };
    function lazyModelChanged() {
        var valueBinding = valueBindingTable.get(this);
        if (valueBinding) valueBinding.setModel(this.model);
        var checkedBinding = checkedBindingTable.get(this);
        if (checkedBinding) checkedBinding.setModel(this.model);
    }
    function lazyModelDelegateChanged() {
        var valueBinding = valueBindingTable.get(this);
        if (valueBinding) valueBinding.setDelegate(this.model, this.modelDelegate);
        var checkedBinding = checkedBindingTable.get(this);
        if (checkedBinding) checkedBinding.setDelegate(this.model, this.modelDelegate);
    }
    modelChangedTable.set(HTMLInputElement.prototype, function() {
        modelChangedTable.get(Element.prototype).call(this);
        if (valueBindingTable.get(this) || checkedBindingTable.get(this)) Model.enqueue(lazyModelChanged.bind(this));
    });
    modelDelegateChangedTable.set(HTMLInputElement.prototype, function() {
        modelDelegateChangedTable.get(Element.prototype).call(this);
        if (valueBindingTable.get(this) || checkedBindingTable.get(this)) Model.enqueue(lazyModelDelegateChanged.bind(this));
    });
})();

(function(global) {
    "use strict";
    function assert(v) {
        if (!v) throw new Error("Assertion failed");
    }
    function isObject(value) {
        return Object(value) === value;
    }
    function toUint32(v) {
        return v >>> 0;
    }
    var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
    var templateAttributeDirectives = {
        template: true,
        iterate: true,
        instantiate: true,
        ref: true
    };
    var semanticTemplateElements = {
        THEAD: true,
        TBODY: true,
        TFOOT: true,
        TH: true,
        TR: true,
        TD: true,
        COLGROUP: true,
        COL: true,
        OPTION: true
    };
    var hasTemplateElement = typeof HTMLTemplateElement !== "undefined";
    var allTemplatesSelectors = "template, " + Object.keys(semanticTemplateElements).map(function(tagName) {
        return tagName.toLowerCase() + "[template]";
    }).join(", ");
    function getTemplateDescendentsOf(node) {
        return node.querySelectorAll(allTemplatesSelectors);
    }
    function isAttributeTemplate(el) {
        return semanticTemplateElements[el.tagName] && el.hasAttribute("template");
    }
    function isTemplate(el) {
        return el.tagName == "TEMPLATE" || isAttributeTemplate(el);
    }
    function isNativeTemplate(el) {
        return hasTemplateElement && el.tagName == "TEMPLATE";
    }
    document.addEventListener("DOMContentLoaded", function(e) {
        bootstrapTemplatesRecursivelyFrom(document);
        Model.notifyChanges();
    }, false);
    function bootstrapTemplatesRecursivelyFrom(node) {
        function bootstrap(template) {
            if (!HTMLTemplateElement.decorate(template)) bootstrapTemplatesRecursivelyFrom(template.content);
        }
        var templateDescendents = getTemplateDescendentsOf(node);
        if (isTemplate(node)) bootstrap(node);
        forEach(templateDescendents, bootstrap);
    }
    if (!hasTemplateElement) {
        global.HTMLTemplateElement = function() {
            throw TypeError("Illegal constructor");
        };
    }
    var hasProto = "__proto__" in {};
    function mixin(to, from) {
        Object.getOwnPropertyNames(from).forEach(function(name) {
            Object.defineProperty(to, name, Object.getOwnPropertyDescriptor(from, name));
        });
    }
    var templateContentsTable = new SideTable("templateContents");
    var templateContentsOwnerTable = new SideTable("templateContentsOwner");
    var templateInstanceRefTable = new SideTable("templateInstanceRef");
    function getTemplateContentsOwner(doc) {
        if (!doc.defaultView) return doc;
        var d = templateContentsOwnerTable.get(doc);
        if (!d) {
            d = doc.implementation.createHTMLDocument("");
            while (d.lastChild) {
                d.removeChild(d.lastChild);
            }
            templateContentsOwnerTable.set(doc, d);
        }
        return d;
    }
    function cloneAndSeperateAttributeTemplate(templateElement) {
        var clone = templateElement.cloneNode(false);
        var attribs = templateElement.attributes;
        var count = attribs.length;
        while (count-- > 0) {
            var attrib = attribs[count];
            if (templateAttributeDirectives[attrib.name]) clone.removeAttribute(attrib.name); else templateElement.removeAttribute(attrib.name);
        }
        return clone;
    }
    function liftNonNativeTemplateChildrenIntoContent(templateElement) {
        var content = templateElement.content;
        if (!isAttributeTemplate(templateElement)) {
            var child;
            while (child = templateElement.firstChild) {
                content.appendChild(child);
            }
            return;
        }
        var newRoot = cloneAndSeperateAttributeTemplate(templateElement);
        var child;
        while (child = templateElement.firstChild) {
            newRoot.appendChild(child);
        }
        content.appendChild(newRoot);
    }
    HTMLTemplateElement.decorate = function(el, opt_instanceRef) {
        if (el.templateIsDecorated_) return false;
        el.templateIsDecorated_ = true;
        fixTemplateElementPrototype(el);
        Model.enqueue(checkIteration.bind(null, el));
        if (!isNativeTemplate(el)) {
            var doc = getTemplateContentsOwner(el.ownerDocument);
            templateContentsTable.set(el, doc.createDocumentFragment());
        }
        if (opt_instanceRef) {
            templateInstanceRefTable.set(el, opt_instanceRef);
            return true;
        }
        if (isNativeTemplate(el)) {
            bootstrapTemplatesRecursivelyFrom(el.content);
        } else {
            liftNonNativeTemplateChildrenIntoContent(el);
        }
        return true;
    };
    HTMLTemplateElement.bootstrap = bootstrapTemplatesRecursivelyFrom;
    var htmlElement = global.HTMLUnknownElement || HTMLElement;
    var contentDescriptor = {
        get: function() {
            return templateContentsTable.get(this);
        },
        enumerable: true,
        configurable: true
    };
    if (!hasTemplateElement) {
        HTMLTemplateElement.prototype = Object.create(htmlElement.prototype);
        Object.defineProperty(HTMLTemplateElement.prototype, "content", contentDescriptor);
    }
    function fixTemplateElementPrototype(el) {
        if (el.tagName === "TEMPLATE") {
            if (!hasTemplateElement) {
                if (hasProto) el.__proto__ = HTMLTemplateElement.prototype; else mixin(el, HTMLTemplateElement.prototype);
            }
        } else {
            mixin(el, HTMLTemplateElement.prototype);
            Object.defineProperty(el, "content", contentDescriptor);
        }
    }
    function createInstance(element, model, modelDelegate) {
        var content = element.ref ? element.ref.content : element.content;
        return createDeepCloneAndDecorateTemplates(content);
    }
    mixin(HTMLTemplateElement.prototype, {
        createInstance: function(model, modelDelegate) {
            return createInstance(this, model, modelDelegate);
        },
        get instantiate() {
            return this.getAttribute("instantiate");
        },
        set instantiate(instantiate) {
            var oldVal = this.instantiate;
            if (instantiate == null) this.removeAttribute("instantiate"); else this.setAttribute("instantiate", instantiate);
            if (instantiate != oldVal) {
                this.removeAttribute("iterate");
                Model.enqueue(checkIteration.bind(null, this));
            }
        },
        get iterate() {
            return this.getAttribute("iterate");
        },
        set iterate(iterate) {
            var oldVal = this.iterate;
            if (iterate == null) this.removeAttribute("iterate"); else this.setAttribute("iterate", iterate);
            if (iterate != oldVal) {
                this.removeAttribute("instantiate");
                Model.enqueue(checkIteration.bind(null, this));
            }
        },
        get ref() {
            var ref;
            var refId = this.getAttribute("ref");
            if (refId) ref = this.ownerDocument.getElementById(refId);
            if (!ref) ref = templateInstanceRefTable.get(this);
            return ref || null;
        }
    });
    function parseSinglePathFromPlaceholder(input, startIndex) {
        assert(input.indexOf("{{") >= 0);
        assert(input.indexOf("}}") >= 0);
        var indexAfterBraces = startIndex + 2;
        var endIndex = input.indexOf("}}", indexAfterBraces);
        return input.slice(indexAfterBraces, endIndex).trim();
    }
    function isCheckBoxOrRadioButton(element) {
        return element.type === "radio" || element.type === "checkbox";
    }
    function addElementBindings(element) {
        assert(element);
        if (!element.hasAttributes()) return;
        for (var i = 0; i < element.attributes.length; i++) {
            var attr = element.attributes[i];
            var index = attr.value.indexOf("{{");
            if (index !== -1 && attr.value.indexOf("}}", index) !== -1) {
                if (element.tagName === "INPUT") {
                    if (attr.name == "value") {
                        var value = attr.value;
                        element.removeAttribute("value");
                        element.addValueBinding(parseSinglePathFromPlaceholder(value, index));
                    } else if (attr.name == "checked" && isCheckBoxOrRadioButton(element)) {
                        var value = attr.value;
                        element.removeAttribute("checked");
                        element.addCheckedBinding(parseSinglePathFromPlaceholder(value, index));
                    } else {
                        element.addBinding(attr.name, attr.value);
                    }
                } else {
                    element.addBinding(attr.name, attr.value);
                }
            }
        }
    }
    function addTextNodeBinding(text) {
        assert(text);
        var index = text.data.indexOf("{{");
        if (index !== -1 && text.data.indexOf("}}", index + 2)) text.addBinding(text.data);
    }
    function addBindings(node) {
        assert(node);
        if (node.nodeType === Node.ELEMENT_NODE) addElementBindings(node); else if (node.nodeType === Node.TEXT_NODE) addTextNodeBinding(node);
        for (var child = node.firstChild; child; child = child.nextSibling) addBindings(child);
    }
    function removeAllBindingsRecursively(node) {
        switch (node.nodeType) {
          case Node.TEXT_NODE:
            node.removeBinding();
            break;

          case Node.ELEMENT_NODE:
            if (node.tagName === "INPUT") {
                node.removeValueBinding();
                node.removeCheckedBinding();
            }
            var length = node.attributes.length;
            for (var i = 0; i < length; i++) {
                node.removeBinding(node.attributes[i]);
            }
            break;
        }
        for (var child = node.firstChild; child; child = child.nextSibling) {
            removeAllBindingsRecursively(child);
        }
    }
    function createDeepCloneAndDecorateTemplates(node) {
        var clone = node.cloneNode(false);
        if (isTemplate(clone)) HTMLTemplateElement.decorate(clone, node);
        for (var child = node.firstChild; child; child = child.nextSibling) {
            clone.appendChild(createDeepCloneAndDecorateTemplates(child));
        }
        return clone;
    }
    function removeChild(parent, child) {
        if (isTemplate(child)) {
            var templateIterator = templateIteratorTable.get(child);
            if (templateIterator) {
                templateIteratorTable.delete(child);
            }
        }
        parent.removeChild(child);
        removeAllBindingsRecursively(child);
        child.model = child.modelDelegate = undefined;
    }
    function InstanceCursor(templateElement, opt_index) {
        this.template_ = templateElement;
        this.previousTerminator_ = null;
        this.previousIndex_ = -1;
        this.terminator_ = templateElement;
        this.index_ = 0;
        if (!opt_index) return;
        while (opt_index-- > 0) {
            this.next();
        }
    }
    InstanceCursor.prototype = {
        next: function() {
            this.previousTerminator_ = this.terminator_;
            this.previousIndex_ = this.index_;
            this.index_++;
            while (this.index_ > instanceTerminatorCount(this.terminator_)) {
                this.index_ -= instanceTerminatorCount(this.terminator_);
                this.terminator_ = this.terminator_.nextSibling;
                if (this.terminator_.tagName === "TEMPLATE") this.index_ += instanceCount(this.terminator_);
            }
        },
        abandon: function() {
            assert(instanceCount(this.template_));
            assert(instanceTerminatorCount(this.terminator_));
            assert(this.index_);
            decrementInstanceTerminatorCount(this.terminator_);
            this.index_--;
        },
        insert: function(model) {
            assert(this.template_.parentNode);
            this.previousTerminator_ = this.terminator_;
            this.previousIndex_ = this.index_;
            this.index_++;
            var instance = createInstance(this.template_);
            for (var child = instance.firstChild; child; child = child.nextSibling) {
                child.model = model;
                child.modelDelegate = this.template_.parentNode.modelDelegate;
            }
            addBindings(instance);
            this.terminator_ = instance.lastChild || this.previousTerminator_;
            this.template_.parentNode.insertBefore(instance, this.previousTerminator_.nextSibling);
            incrementInstanceTerminatorCount(this.terminator_);
            if (this.terminator_ !== this.previousTerminator_) {
                while (instanceTerminatorCount(this.previousTerminator_) > this.previousIndex_) {
                    decrementInstanceTerminatorCount(this.previousTerminator_);
                    incrementInstanceTerminatorCount(this.terminator_);
                }
            }
        },
        remove: function() {
            assert(this.previousIndex_ !== -1);
            assert(this.previousTerminator_ && (this.previousIndex_ > 0 || this.previousTerminator_ === this.template_));
            assert(this.terminator_ && this.index_ > 0);
            assert(this.template_.parentNode);
            assert(instanceCount(this.template_));
            if (this.previousTerminator_ === this.terminator_) {
                assert(this.index_ == this.previousIndex_ + 1);
                decrementInstanceTerminatorCount(this.terminator_);
                this.terminator_ = this.template_;
                this.previousTerminator_ = null;
                this.previousIndex_ = -1;
                return;
            }
            decrementInstanceTerminatorCount(this.terminator_);
            var parent = this.template_.parentNode;
            while (this.previousTerminator_.nextSibling !== this.terminator_) {
                removeChild(parent, this.previousTerminator_.nextSibling);
            }
            removeChild(parent, this.terminator_);
            this.terminator_ = this.previousTerminator_;
            this.index_ = this.previousIndex_;
            this.previousTerminator_ = null;
            this.previousIndex_ = -1;
        }
    };
    var ONE_WAY = DelegatedValueBinding.Type.ONE_WAY;
    function TemplateIterator(templateElement, bindingText, isIterate) {
        this.templateElement_ = templateElement;
        this.binding_ = new DelegatedValueBinding(templateElement.model, templateElement.modelDelegate, bindingText, ONE_WAY, this);
        this.bindingText_ = bindingText;
        this.isIterate_ = isIterate;
        this.iteratedValue = undefined;
        this.observing = false;
        this.instanceCount = 0;
        this.boundHandleSplices = this.handleSplices.bind(this);
        this.valueChanged(this.binding_);
    }
    TemplateIterator.prototype = {
        get bindingText() {
            return this.bindingText_;
        },
        get isIterate() {
            return this.isIterate_;
        },
        valueChanged: function(binding) {
            this.clear();
            if (this.binding_.value == null) return;
            if (this.isIterate_ && !Array.isArray(this.binding_.value)) return;
            this.iteratedValue = this.isIterate_ ? this.binding_.value : [ this.binding_.value ];
            if (this.isIterate_) {
                Model.observeArray(this.iteratedValue, this.boundHandleSplices);
                this.observing = true;
            }
            this.handleSplices([ {
                index: 0,
                addedCount: this.iteratedValue.length,
                removed: []
            } ]);
        },
        handleSplices: function(splices) {
            splices.forEach(function(splice) {
                splice.removed.forEach(function() {
                    var cursor = new InstanceCursor(this.templateElement_, splice.index + 1);
                    cursor.remove();
                    this.instanceCount--;
                }, this);
                var addIndex = splice.index;
                for (;addIndex < splice.index + splice.addedCount; addIndex++) {
                    var cursor = new InstanceCursor(this.templateElement_, addIndex);
                    cursor.insert(this.iteratedValue[addIndex]);
                    this.instanceCount++;
                }
            }, this);
        },
        setModel: function(model) {
            if (this.binding_.setModel(model)) {
                this.valueChanged(this.binding_);
                return true;
            }
            return false;
        },
        setDelegate: function(model, delegate) {
            if (this.binding_.setDelegate(model, delegate)) {
                this.valueChanged(this.binding_);
                return true;
            }
            return false;
        },
        clear: function() {
            if (this.observing) {
                Model.unobserveArray(this.iteratedValue, this.boundHandleSplices);
                this.observing = false;
            }
            this.iteratedValue = undefined;
            if (!this.instanceCount) return;
            for (var i = 0; i < this.instanceCount; i++) {
                var cursor = new InstanceCursor(this.templateElement_, 1);
                cursor.remove();
            }
            this.instanceCount = 0;
        }
    };
    var templateIteratorTable = new SideTable("templateIterator");
    function instanceCount(element) {
        var templateIterator = templateIteratorTable.get(element);
        return templateIterator ? templateIterator.instanceCount : 0;
    }
    function checkIteration(element) {
        var bindingText;
        var isIterate = false;
        if (element.parentNode && element.ownerDocument.defaultView) {
            bindingText = element.getAttribute("instantiate");
            if (bindingText === null) {
                isIterate = true;
                bindingText = element.getAttribute("iterate");
            }
        }
        var templateIterator = templateIteratorTable.get(element);
        if (templateIterator && templateIterator.bindingText === element.bindingText && templateIterator.isIterate === isIterate) {
            return;
        }
        if (templateIterator) {
            templateIterator.clear();
            templateIteratorTable.delete(element);
        }
        if (bindingText == null) return;
        templateIterator = new TemplateIterator(element, bindingText, isIterate);
        templateIteratorTable.set(element, templateIterator);
    }
    modelChangedTable.set(HTMLTemplateElement.prototype, function() {
        modelChangedTable.get(Element.prototype).call(this);
        var templateIterator = templateIteratorTable.get(this);
        if (templateIterator) Model.enqueue(lazyModelChanged.bind(this));
    });
    modelDelegateChangedTable.set(HTMLTemplateElement.prototype, function() {
        modelDelegateChangedTable.get(Element.prototype).call(this);
        var templateIterator = templateIteratorTable.get(this);
        if (templateIterator) Model.enqueue(lazyModelDelegateChanged.bind(this));
    });
    function lazyModelChanged() {
        var templateIterator = templateIteratorTable.get(this);
        if (templateIterator) templateIterator.setModel(this.model);
    }
    function lazyModelDelegateChanged() {
        var templateIterator = templateIteratorTable.get(this);
        if (templateIterator) templateIterator.setDelegate(this.model, this.modelDelegate);
    }
    function InstanceTerminatorCount() {
        this.instanceTerminatorCount_ = 0;
    }
    InstanceTerminatorCount.prototype = {
        instanceTerminatorCount: function() {
            return this.instanceTerminatorCount_;
        },
        incrementInstanceTerminatorCount: function() {
            this.instanceTerminatorCount_++;
        },
        decrementInstanceTerminatorCount: function() {
            this.instanceTerminatorCount_--;
        }
    };
    var instanceTerminatorCountTable = new SideTable("instanceTerminatorCount");
    function ensureInstanceTerminatorCount(node) {
        var count = instanceTerminatorCountTable.get(node);
        if (!count) {
            count = new InstanceTerminatorCount();
            instanceTerminatorCountTable.set(node, count);
        }
        return count;
    }
    function incrementInstanceTerminatorCount(node) {
        ensureInstanceTerminatorCount(node).incrementInstanceTerminatorCount();
    }
    function decrementInstanceTerminatorCount(node) {
        ensureInstanceTerminatorCount(node).decrementInstanceTerminatorCount();
    }
    function instanceTerminatorCount(node) {
        var data = instanceTerminatorCountTable.get(node);
        return data ? data.instanceTerminatorCount() : 0;
    }
    HTMLTemplateElement.allTemplatesSelectors = allTemplatesSelectors;
})(this);

(function(global) {
    "use strict";
    function Transform() {}
    Transform.registry = {};
    Transform.create = function(transformName, transformArgs) {
        var transform;
        var transFunc = Transform.registry[transformName];
        if (transformName && typeof transFunc == "function") {
            transform = Object.create(transFunc.prototype);
            transFunc.apply(transform, transformArgs);
        }
        return transform;
    };
    function ToggleTransform(value) {
        this.value = value;
    }
    Transform.registry.toggle = ToggleTransform;
    ToggleTransform.prototype = {
        toTarget: function(source, sourceName) {
            return source ? this.value || sourceName : "";
        },
        toSource: function(target, sourceName) {
            return (this.value || sourceName) == target;
        }
    };
    function CurrencyTransform() {}
    Transform.registry.currency = CurrencyTransform;
    CurrencyTransform.prototype = {
        pattern: /^\$?([-\d\.]*)$/,
        toTarget: function(source) {
            var num = Number(source);
            return isNaN(num) ? "NaN" : "$" + Number(num).toFixed(2);
        },
        toSource: function(target) {
            var m = target.match(this.pattern) || {};
            return Number(m[1]);
        }
    };
    function NumberTransform() {}
    Transform.registry.number = NumberTransform;
    NumberTransform.prototype = {
        toTarget: function(source) {
            return String(source);
        },
        toSource: function(target) {
            return Number(target);
        }
    };
    function AbsentTransform() {}
    Transform.registry.absent = AbsentTransform;
    AbsentTransform.prototype = {
        toTarget: function(source) {
            if (!source) return true;
            if (typeof source == "object" && "length" in source && source.length) return true;
            return null;
        }
    };
    function PresentTransform() {}
    Transform.registry.present = PresentTransform;
    PresentTransform.prototype = {
        toTarget: function(source) {
            return !AbsentTransform.prototype.toTarget(source) || null;
        }
    };
    global.Transform = Transform;
})(window);

function MDVDelegate(binding) {
    function strip(s) {
        return s.replace(/\s/g, "");
    }
    function createExpression(args, body) {
        var args = strip(args);
        args = args ? args.split(",") : [];
        var functionBody = "return (" + body + ")";
        var deps = [], aliases = [];
        for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            var parts = arg.split("@");
            var path = strip(parts[0]);
            if (!path) return;
            var alias;
            if (parts.length > 1) {
                alias = strip(parts[1]);
            } else {
                var index = path.indexOf(".");
                if (index < 0) alias = path; else alias = path.substring(index + 1);
            }
            if (alias.length == 0) return;
            deps.push(path);
            aliases.push(alias);
        }
        return [ deps, Function.apply(null, aliases.concat(functionBody)) ];
    }
    var expressionPattern = /^expr\s*\(([^)]*)\s*\)\s*((?:.|\n)*)$/m;
    var match = binding.match(expressionPattern);
    if (match != null) return createExpression(match[1], match[2]);
    function createConditional(outputPath, conditional, exprArgs, exprBody, conditionalInput) {
        var isIf = conditional == "if";
        if (!exprArgs) {
            return [ [ outputPath, conditionalInput ], function(a, b) {
                return b ? isIf ? a : undefined : isIf ? undefined : a;
            } ];
        }
        var expr = createExpression(exprArgs, exprBody);
        return [ [ outputPath ].concat(expr[0]), function() {
            var retval = arguments[0];
            var args = Array.prototype.slice.call(arguments, 1);
            var result = expr[1].apply(undefined, args);
            return result ? isIf ? retval : undefined : isIf ? undefined : retval;
        } ];
    }
    var conditionalPattern = /^\s*(\S*)\s+(if|unless)\s+(expr\s*\(([^)]*)\s*\)\s*((?:.|\n)*)$|(\S*))/m;
    var match = binding.match(conditionalPattern);
    if (match != null) return createConditional(match[1], match[2], match[4], match[5], match[6]);
    function createTransform(binding, index) {
        var path = binding.substring(0, index).trim();
        var s = binding.substring(index + 1).trim();
        var stringArg = /^(?:"([^"]*)"|'([^']*)')$/;
        var transformPattern = /^([a-z_]+[a-z_\d]*)(?:\(([^\)]*)\))?$/i;
        var m = s.match(transformPattern);
        if (m == null) return;
        var transformName = m[1].trim();
        var transformArgsString = m[2];
        if (transformArgsString) transformArgsString = transformArgsString.trim();
        var args = transformArgsString ? transformArgsString.split(",") : [];
        var transformArgs = args.map(function(arg) {
            arg = arg.trim();
            if (arg === "") return undefined;
            if (stringArg.test(arg)) {
                var m = arg.match(stringArg);
                return m[1] || m[2];
            }
            switch (arg) {
              case "true":
                return true;

              case "false":
                return false;

              case "null":
                return null;

              default:
                var number = Number(arg);
                return !isNaN(number) ? number : undefined;
            }
        });
        var transform = Transform.create(transformName, transformArgs);
        var name;
        var index = path.indexOf(".");
        if (index < 0) name = path; else name = path.substring(index + 1);
        return [ [ path ], function() {
            return transform.toTarget.apply(transform, Array.prototype.slice.apply(arguments).concat(name));
        }, function(value) {
            return transform.toSource.apply(transform, [ value ]);
        } ];
    }
    var index = binding.indexOf("|");
    if (index >= 0) return createTransform(binding, index);
    return null;
}

(function() {
    var check = function() {
        Model.notifyChanges();
    };
    window.dirtyCheck = function() {
        logFlags.data && console.group("Model.dirtyCheck()");
        check();
        logFlags.data && console.groupEnd();
    };
    window.addEventListener("WebComponentsReady", function() {
        dirtyCheck();
        setInterval(check, 125);
    });
})();

var generateMatcher = function(inSlctr) {
    if (!inSlctr) {
        return;
    }
    var c = inSlctr[0];
    if (inSlctr === "~") {
        return function(inNode) {
            return Boolean(inNode.lightDOM);
        };
    }
    if (c === "#") {
        m = inSlctr.slice(1);
        return function(inNode) {
            return inNode.id === m;
        };
    }
    if (inSlctr === "*") {
        return function(inNode) {
            return inNode.nodeName !== "#text";
        };
    }
    if (c === ".") {
        m = inSlctr.slice(1);
        return function(inNode) {
            return inNode.classList && inNode.classList.contains(m);
        };
    }
    if (c === "[") {
        m = inSlctr.slice(1, -1);
        return function(inNode) {
            return inNode.hasAttribute && inNode.hasAttribute(m);
        };
    }
    var slctrs = inSlctr.toLowerCase().split(",");
    return function(inNode) {
        return slctrs.indexOf(inNode.localName) >= 0;
    };
};

var isInsertionPoint = function(inNode) {
    return {
        SHADOW: 1,
        CONTENT: 1
    }[inNode.tagName];
};

var search = function(inNodes, inMatcher) {
    var results = [];
    for (var i = 0, n; n = inNodes[i]; i++) {
        if (inMatcher(n)) {
            results.push(n);
        }
        if (!isInsertionPoint(n)) {
            results = results.concat(_search(n, inMatcher));
        }
    }
    return results;
};

var _search = function(inNode, inMatcher) {
    return search(inNode.childNodes, inMatcher);
};

var localQueryAll = function(inNode, inSlctr) {
    var results = search(inNode.childNodes, generateMatcher(inSlctr));
    return results;
};

var localQuery = function(inNode, inSlctr) {
    return localQueryAll(inNode, inSlctr)[0];
};

(function() {
    var inspector;
    window.sinspect = function(inNode, inProxy) {
        if (!inspector) {
            inspector = window.open("", "ShadowDOM Inspector", null, true);
            inspector.document.write(extractHtml(containHtml.toString()));
            inspector.api = {
                shadowize: shadowize
            };
        }
        inspect(inNode || wrap(document.body), inProxy);
    };
    var crumbs = [];
    var displayCrumbs = function() {
        var d = inspector.document;
        var cb = d.querySelector("#crumbs");
        cb.textContent = "";
        for (var i = 0, c; c = crumbs[i]; i++) {
            var a = d.createElement("a");
            a.href = "#";
            a.textContent = c.localName;
            a.idx = i;
            a.onclick = function(event) {
                var c;
                while (crumbs.length > this.idx) {
                    c = crumbs.pop();
                }
                inspect(c.shadow || c, c);
                event.preventDefault();
            };
            cb.appendChild(d.createElement("li")).appendChild(a);
        }
    };
    var inspect = function(inNode, inProxy) {
        var d = inspector.document;
        drillable = [];
        var proxy = inProxy || inNode;
        crumbs.push(proxy);
        displayCrumbs();
        d.body.querySelector("#tree").innerHTML = "<pre>" + output(inNode, inNode.childNodes) + "</pre>";
    };
    var containHtml = function() {};
    var extractHtml = function(inCode) {
        var rx = /\/\*[\w\t\n\r]*([\s\S]*?)[\w\t\n\r]*\*\//;
        var html = inCode.toString().match(rx)[1];
        return html;
    };
    var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
    var blacklisted = {
        STYLE: 1,
        SCRIPT: 1,
        "#comment": 1,
        TEMPLATE: 1
    };
    var blacklist = function(inNode) {
        return blacklisted[inNode.nodeName];
    };
    var output = function(inNode, inChildNodes, inIndent) {
        if (blacklist(inNode)) {
            return "";
        }
        var indent = inIndent || "";
        if (inNode.localName || inNode.nodeType == 11) {
            var name = inNode.localName || "shadow-root";
            var info = indent + describe(inNode);
            {
                if (name == "content") {
                    inChildNodes = inNode.getDistributedNodes();
                }
                info += "<br/>";
                var ind = indent + "&nbsp;&nbsp;";
                forEach(inChildNodes, function(n) {
                    info += output(n, n.childNodes, ind);
                });
                info += indent;
            }
            if (!{
                br: 1
            }[name]) {
                info += "<tag>&lt;/" + name + "&gt;</tag>";
                info += "<br/>";
            }
        } else {
            var text = inNode.textContent.trim();
            info = text ? indent + '"' + text + '"' + "<br/>" : "";
        }
        return info;
    };
    var catTextContent = function(inChildNodes) {
        var info = "";
        forEach(inChildNodes, function(n) {
            info += n.textContent.trim();
        });
        return info;
    };
    var drillable = [];
    var describe = function(inNode) {
        var tag = "<tag>" + "&lt;";
        var name = inNode.localName || "shadow-root";
        if (inNode.webkitShadowRoot || inNode.shadowRoot) {
            tag += ' <button idx="' + drillable.length + '" onclick="api.shadowize.call(this)">' + name + "</button>";
            drillable.push(inNode);
        } else {
            tag += name || "shadow-root";
        }
        if (inNode.attributes) {
            forEach(inNode.attributes, function(a) {
                tag += " " + a.name + (a.value ? '="' + a.value + '"' : "");
            });
        }
        tag += "&gt;" + "</tag>";
        return tag;
    };
    shadowize = function() {
        var idx = Number(this.attributes.idx.value);
        var node = drillable[idx];
        if (node) {
            inspect(node.webkitShadowRoot || node.shadowRoot, node);
        } else {
            console.log("bad shadowize node");
            console.dir(this);
        }
    };
})();

window.templateContent = window.templateContent || function(inTemplate) {
    return inTemplate.content;
};

if (!window.WrapperElement) {
    window.wrap = function(n) {
        return n;
    };
    window.createShadowRoot = function(inElement) {
        return inElement.webkitCreateShadowRoot();
    };
    window.templateContent = function(inTemplate) {
        if (!inTemplate.content && !inTemplate._content) {
            var frag = document.createDocumentFragment();
            while (inTemplate.firstChild) {
                frag.appendChild(inTemplate.firstChild);
            }
            inTemplate._content = frag;
        }
        return inTemplate.content || inTemplate._content;
    };
} else {
    var queryPropDefs = {
        querySelector: {
            value: function(inSlctr) {
                return localQuery(this, inSlctr);
            }
        },
        querySelectorAll: {
            value: function(inSlctr) {
                return localQueryAll(this, inSlctr);
            }
        }
    };
    Object.defineProperties(WrapperElement.prototype, queryPropDefs);
    Object.defineProperties(WrapperDocument.prototype, queryPropDefs);
    Object.defineProperties(WrapperShadowRoot.prototype, queryPropDefs);
    Object.defineProperties(WrapperElement.prototype, {
        webkitShadowRoot: {
            get: function() {
                return this.shadowRoot;
            }
        }
    });
    WrapperElement.prototype.webkitCreateShadowRoot = WrapperElement.prototype.createShadowRoot;
}